// Code generated by counterfeiter. DO NOT EDIT.
package repositoryfakes

import (
	"context"
	"sync"

	"github.com/vmware-tanzu/cartographer/pkg/apis/v1alpha1"
	"github.com/vmware-tanzu/cartographer/pkg/repository"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type FakeRepository struct {
	EnsureImmutableObjectExistsOnClusterStub        func(context.Context, *unstructured.Unstructured, map[string]string) error
	ensureImmutableObjectExistsOnClusterMutex       sync.RWMutex
	ensureImmutableObjectExistsOnClusterArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
		arg3 map[string]string
	}
	ensureImmutableObjectExistsOnClusterReturns struct {
		result1 error
	}
	ensureImmutableObjectExistsOnClusterReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureMutableObjectExistsOnClusterStub        func(context.Context, *unstructured.Unstructured) error
	ensureMutableObjectExistsOnClusterMutex       sync.RWMutex
	ensureMutableObjectExistsOnClusterArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}
	ensureMutableObjectExistsOnClusterReturns struct {
		result1 error
	}
	ensureMutableObjectExistsOnClusterReturnsOnCall map[int]struct {
		result1 error
	}
	GetClusterTemplateStub        func(context.Context, v1alpha1.ClusterTemplateReference) (client.Object, error)
	getClusterTemplateMutex       sync.RWMutex
	getClusterTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 v1alpha1.ClusterTemplateReference
	}
	getClusterTemplateReturns struct {
		result1 client.Object
		result2 error
	}
	getClusterTemplateReturnsOnCall map[int]struct {
		result1 client.Object
		result2 error
	}
	GetDeliverableStub        func(context.Context, string, string) (*v1alpha1.Deliverable, error)
	getDeliverableMutex       sync.RWMutex
	getDeliverableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getDeliverableReturns struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	getDeliverableReturnsOnCall map[int]struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	GetDeliveriesForDeliverableStub        func(context.Context, *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error)
	getDeliveriesForDeliverableMutex       sync.RWMutex
	getDeliveriesForDeliverableArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.Deliverable
	}
	getDeliveriesForDeliverableReturns struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveriesForDeliverableReturnsOnCall map[int]struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}
	GetDeliveryStub        func(context.Context, string) (*v1alpha1.ClusterDelivery, error)
	getDeliveryMutex       sync.RWMutex
	getDeliveryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDeliveryReturns struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveryReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	GetDeliveryClusterTemplateStub        func(context.Context, v1alpha1.DeliveryClusterTemplateReference) (client.Object, error)
	getDeliveryClusterTemplateMutex       sync.RWMutex
	getDeliveryClusterTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 v1alpha1.DeliveryClusterTemplateReference
	}
	getDeliveryClusterTemplateReturns struct {
		result1 client.Object
		result2 error
	}
	getDeliveryClusterTemplateReturnsOnCall map[int]struct {
		result1 client.Object
		result2 error
	}
	GetRunTemplateStub        func(context.Context, v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error)
	getRunTemplateMutex       sync.RWMutex
	getRunTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 v1alpha1.TemplateReference
	}
	getRunTemplateReturns struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}
	getRunTemplateReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}
	GetRunnableStub        func(context.Context, string, string) (*v1alpha1.Runnable, error)
	getRunnableMutex       sync.RWMutex
	getRunnableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getRunnableReturns struct {
		result1 *v1alpha1.Runnable
		result2 error
	}
	getRunnableReturnsOnCall map[int]struct {
		result1 *v1alpha1.Runnable
		result2 error
	}
	GetSchemeStub        func() *runtime.Scheme
	getSchemeMutex       sync.RWMutex
	getSchemeArgsForCall []struct {
	}
	getSchemeReturns struct {
		result1 *runtime.Scheme
	}
	getSchemeReturnsOnCall map[int]struct {
		result1 *runtime.Scheme
	}
	GetServiceAccountSecretStub        func(context.Context, string, string) (*v1.Secret, error)
	getServiceAccountSecretMutex       sync.RWMutex
	getServiceAccountSecretArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getServiceAccountSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	getServiceAccountSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	GetSupplyChainStub        func(context.Context, string) (*v1alpha1.ClusterSupplyChain, error)
	getSupplyChainMutex       sync.RWMutex
	getSupplyChainArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getSupplyChainReturns struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetSupplyChainsForWorkloadStub        func(context.Context, *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error)
	getSupplyChainsForWorkloadMutex       sync.RWMutex
	getSupplyChainsForWorkloadArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.Workload
	}
	getSupplyChainsForWorkloadReturns struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainsForWorkloadReturnsOnCall map[int]struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetUnstructuredStub        func(context.Context, string, string) (*unstructured.Unstructured, error)
	getUnstructuredMutex       sync.RWMutex
	getUnstructuredArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getUnstructuredReturns struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	getUnstructuredReturnsOnCall map[int]struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	GetWorkloadStub        func(context.Context, string, string) (*v1alpha1.Workload, error)
	getWorkloadMutex       sync.RWMutex
	getWorkloadArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getWorkloadReturns struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	getWorkloadReturnsOnCall map[int]struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	ListUnstructuredStub        func(context.Context, schema.GroupVersionKind, string, map[string]string) ([]*unstructured.Unstructured, error)
	listUnstructuredMutex       sync.RWMutex
	listUnstructuredArgsForCall []struct {
		arg1 context.Context
		arg2 schema.GroupVersionKind
		arg3 string
		arg4 map[string]string
	}
	listUnstructuredReturns struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	listUnstructuredReturnsOnCall map[int]struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	StatusUpdateStub        func(context.Context, client.Object) error
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
	}
	statusUpdateReturns struct {
		result1 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnCluster(arg1 context.Context, arg2 *unstructured.Unstructured, arg3 map[string]string) error {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	ret, specificReturn := fake.ensureImmutableObjectExistsOnClusterReturnsOnCall[len(fake.ensureImmutableObjectExistsOnClusterArgsForCall)]
	fake.ensureImmutableObjectExistsOnClusterArgsForCall = append(fake.ensureImmutableObjectExistsOnClusterArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.EnsureImmutableObjectExistsOnClusterStub
	fakeReturns := fake.ensureImmutableObjectExistsOnClusterReturns
	fake.recordInvocation("EnsureImmutableObjectExistsOnCluster", []interface{}{arg1, arg2, arg3})
	fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterCallCount() int {
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	return len(fake.ensureImmutableObjectExistsOnClusterArgsForCall)
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterCalls(stub func(context.Context, *unstructured.Unstructured, map[string]string) error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = stub
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterArgsForCall(i int) (context.Context, *unstructured.Unstructured, map[string]string) {
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	argsForCall := fake.ensureImmutableObjectExistsOnClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterReturns(result1 error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = nil
	fake.ensureImmutableObjectExistsOnClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterReturnsOnCall(i int, result1 error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = nil
	if fake.ensureImmutableObjectExistsOnClusterReturnsOnCall == nil {
		fake.ensureImmutableObjectExistsOnClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureImmutableObjectExistsOnClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnCluster(arg1 context.Context, arg2 *unstructured.Unstructured) error {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	ret, specificReturn := fake.ensureMutableObjectExistsOnClusterReturnsOnCall[len(fake.ensureMutableObjectExistsOnClusterArgsForCall)]
	fake.ensureMutableObjectExistsOnClusterArgsForCall = append(fake.ensureMutableObjectExistsOnClusterArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}{arg1, arg2})
	stub := fake.EnsureMutableObjectExistsOnClusterStub
	fakeReturns := fake.ensureMutableObjectExistsOnClusterReturns
	fake.recordInvocation("EnsureMutableObjectExistsOnCluster", []interface{}{arg1, arg2})
	fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterCallCount() int {
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	return len(fake.ensureMutableObjectExistsOnClusterArgsForCall)
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterCalls(stub func(context.Context, *unstructured.Unstructured) error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = stub
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterArgsForCall(i int) (context.Context, *unstructured.Unstructured) {
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	argsForCall := fake.ensureMutableObjectExistsOnClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterReturns(result1 error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = nil
	fake.ensureMutableObjectExistsOnClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterReturnsOnCall(i int, result1 error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = nil
	if fake.ensureMutableObjectExistsOnClusterReturnsOnCall == nil {
		fake.ensureMutableObjectExistsOnClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureMutableObjectExistsOnClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetClusterTemplate(arg1 context.Context, arg2 v1alpha1.ClusterTemplateReference) (client.Object, error) {
	fake.getClusterTemplateMutex.Lock()
	ret, specificReturn := fake.getClusterTemplateReturnsOnCall[len(fake.getClusterTemplateArgsForCall)]
	fake.getClusterTemplateArgsForCall = append(fake.getClusterTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 v1alpha1.ClusterTemplateReference
	}{arg1, arg2})
	stub := fake.GetClusterTemplateStub
	fakeReturns := fake.getClusterTemplateReturns
	fake.recordInvocation("GetClusterTemplate", []interface{}{arg1, arg2})
	fake.getClusterTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetClusterTemplateCallCount() int {
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	return len(fake.getClusterTemplateArgsForCall)
}

func (fake *FakeRepository) GetClusterTemplateCalls(stub func(context.Context, v1alpha1.ClusterTemplateReference) (client.Object, error)) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = stub
}

func (fake *FakeRepository) GetClusterTemplateArgsForCall(i int) (context.Context, v1alpha1.ClusterTemplateReference) {
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	argsForCall := fake.getClusterTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetClusterTemplateReturns(result1 client.Object, result2 error) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = nil
	fake.getClusterTemplateReturns = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetClusterTemplateReturnsOnCall(i int, result1 client.Object, result2 error) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = nil
	if fake.getClusterTemplateReturnsOnCall == nil {
		fake.getClusterTemplateReturnsOnCall = make(map[int]struct {
			result1 client.Object
			result2 error
		})
	}
	fake.getClusterTemplateReturnsOnCall[i] = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliverable(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Deliverable, error) {
	fake.getDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliverableReturnsOnCall[len(fake.getDeliverableArgsForCall)]
	fake.getDeliverableArgsForCall = append(fake.getDeliverableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetDeliverableStub
	fakeReturns := fake.getDeliverableReturns
	fake.recordInvocation("GetDeliverable", []interface{}{arg1, arg2, arg3})
	fake.getDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliverableCallCount() int {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	return len(fake.getDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliverableCalls(stub func(context.Context, string, string) (*v1alpha1.Deliverable, error)) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliverableArgsForCall(i int) (context.Context, string, string) {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliverableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetDeliverableReturns(result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	fake.getDeliverableReturns = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliverableReturnsOnCall(i int, result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	if fake.getDeliverableReturnsOnCall == nil {
		fake.getDeliverableReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Deliverable
			result2 error
		})
	}
	fake.getDeliverableReturnsOnCall[i] = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverable(arg1 context.Context, arg2 *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliveriesForDeliverableReturnsOnCall[len(fake.getDeliveriesForDeliverableArgsForCall)]
	fake.getDeliveriesForDeliverableArgsForCall = append(fake.getDeliveriesForDeliverableArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.Deliverable
	}{arg1, arg2})
	stub := fake.GetDeliveriesForDeliverableStub
	fakeReturns := fake.getDeliveriesForDeliverableReturns
	fake.recordInvocation("GetDeliveriesForDeliverable", []interface{}{arg1, arg2})
	fake.getDeliveriesForDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCallCount() int {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	return len(fake.getDeliveriesForDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCalls(stub func(context.Context, *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliveriesForDeliverableArgsForCall(i int) (context.Context, *v1alpha1.Deliverable) {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliveriesForDeliverableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturns(result1 []*v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	fake.getDeliveriesForDeliverableReturns = struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturnsOnCall(i int, result1 []*v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	if fake.getDeliveriesForDeliverableReturnsOnCall == nil {
		fake.getDeliveriesForDeliverableReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveriesForDeliverableReturnsOnCall[i] = struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDelivery(arg1 context.Context, arg2 string) (*v1alpha1.ClusterDelivery, error) {
	fake.getDeliveryMutex.Lock()
	ret, specificReturn := fake.getDeliveryReturnsOnCall[len(fake.getDeliveryArgsForCall)]
	fake.getDeliveryArgsForCall = append(fake.getDeliveryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDeliveryStub
	fakeReturns := fake.getDeliveryReturns
	fake.recordInvocation("GetDelivery", []interface{}{arg1, arg2})
	fake.getDeliveryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveryCallCount() int {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	return len(fake.getDeliveryArgsForCall)
}

func (fake *FakeRepository) GetDeliveryCalls(stub func(context.Context, string) (*v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = stub
}

func (fake *FakeRepository) GetDeliveryArgsForCall(i int) (context.Context, string) {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	argsForCall := fake.getDeliveryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliveryReturns(result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	fake.getDeliveryReturns = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryReturnsOnCall(i int, result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	if fake.getDeliveryReturnsOnCall == nil {
		fake.getDeliveryReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveryReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryClusterTemplate(arg1 context.Context, arg2 v1alpha1.DeliveryClusterTemplateReference) (client.Object, error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	ret, specificReturn := fake.getDeliveryClusterTemplateReturnsOnCall[len(fake.getDeliveryClusterTemplateArgsForCall)]
	fake.getDeliveryClusterTemplateArgsForCall = append(fake.getDeliveryClusterTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 v1alpha1.DeliveryClusterTemplateReference
	}{arg1, arg2})
	stub := fake.GetDeliveryClusterTemplateStub
	fakeReturns := fake.getDeliveryClusterTemplateReturns
	fake.recordInvocation("GetDeliveryClusterTemplate", []interface{}{arg1, arg2})
	fake.getDeliveryClusterTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveryClusterTemplateCallCount() int {
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	return len(fake.getDeliveryClusterTemplateArgsForCall)
}

func (fake *FakeRepository) GetDeliveryClusterTemplateCalls(stub func(context.Context, v1alpha1.DeliveryClusterTemplateReference) (client.Object, error)) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = stub
}

func (fake *FakeRepository) GetDeliveryClusterTemplateArgsForCall(i int) (context.Context, v1alpha1.DeliveryClusterTemplateReference) {
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	argsForCall := fake.getDeliveryClusterTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliveryClusterTemplateReturns(result1 client.Object, result2 error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = nil
	fake.getDeliveryClusterTemplateReturns = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryClusterTemplateReturnsOnCall(i int, result1 client.Object, result2 error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = nil
	if fake.getDeliveryClusterTemplateReturnsOnCall == nil {
		fake.getDeliveryClusterTemplateReturnsOnCall = make(map[int]struct {
			result1 client.Object
			result2 error
		})
	}
	fake.getDeliveryClusterTemplateReturnsOnCall[i] = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunTemplate(arg1 context.Context, arg2 v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error) {
	fake.getRunTemplateMutex.Lock()
	ret, specificReturn := fake.getRunTemplateReturnsOnCall[len(fake.getRunTemplateArgsForCall)]
	fake.getRunTemplateArgsForCall = append(fake.getRunTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 v1alpha1.TemplateReference
	}{arg1, arg2})
	stub := fake.GetRunTemplateStub
	fakeReturns := fake.getRunTemplateReturns
	fake.recordInvocation("GetRunTemplate", []interface{}{arg1, arg2})
	fake.getRunTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetRunTemplateCallCount() int {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	return len(fake.getRunTemplateArgsForCall)
}

func (fake *FakeRepository) GetRunTemplateCalls(stub func(context.Context, v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error)) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = stub
}

func (fake *FakeRepository) GetRunTemplateArgsForCall(i int) (context.Context, v1alpha1.TemplateReference) {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	argsForCall := fake.getRunTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetRunTemplateReturns(result1 *v1alpha1.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	fake.getRunTemplateReturns = struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunTemplateReturnsOnCall(i int, result1 *v1alpha1.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	if fake.getRunTemplateReturnsOnCall == nil {
		fake.getRunTemplateReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterRunTemplate
			result2 error
		})
	}
	fake.getRunTemplateReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunnable(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Runnable, error) {
	fake.getRunnableMutex.Lock()
	ret, specificReturn := fake.getRunnableReturnsOnCall[len(fake.getRunnableArgsForCall)]
	fake.getRunnableArgsForCall = append(fake.getRunnableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetRunnableStub
	fakeReturns := fake.getRunnableReturns
	fake.recordInvocation("GetRunnable", []interface{}{arg1, arg2, arg3})
	fake.getRunnableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetRunnableCallCount() int {
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	return len(fake.getRunnableArgsForCall)
}

func (fake *FakeRepository) GetRunnableCalls(stub func(context.Context, string, string) (*v1alpha1.Runnable, error)) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = stub
}

func (fake *FakeRepository) GetRunnableArgsForCall(i int) (context.Context, string, string) {
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	argsForCall := fake.getRunnableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetRunnableReturns(result1 *v1alpha1.Runnable, result2 error) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = nil
	fake.getRunnableReturns = struct {
		result1 *v1alpha1.Runnable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunnableReturnsOnCall(i int, result1 *v1alpha1.Runnable, result2 error) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = nil
	if fake.getRunnableReturnsOnCall == nil {
		fake.getRunnableReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Runnable
			result2 error
		})
	}
	fake.getRunnableReturnsOnCall[i] = struct {
		result1 *v1alpha1.Runnable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetScheme() *runtime.Scheme {
	fake.getSchemeMutex.Lock()
	ret, specificReturn := fake.getSchemeReturnsOnCall[len(fake.getSchemeArgsForCall)]
	fake.getSchemeArgsForCall = append(fake.getSchemeArgsForCall, struct {
	}{})
	stub := fake.GetSchemeStub
	fakeReturns := fake.getSchemeReturns
	fake.recordInvocation("GetScheme", []interface{}{})
	fake.getSchemeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) GetSchemeCallCount() int {
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	return len(fake.getSchemeArgsForCall)
}

func (fake *FakeRepository) GetSchemeCalls(stub func() *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = stub
}

func (fake *FakeRepository) GetSchemeReturns(result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	fake.getSchemeReturns = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetSchemeReturnsOnCall(i int, result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	if fake.getSchemeReturnsOnCall == nil {
		fake.getSchemeReturnsOnCall = make(map[int]struct {
			result1 *runtime.Scheme
		})
	}
	fake.getSchemeReturnsOnCall[i] = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetServiceAccountSecret(arg1 context.Context, arg2 string, arg3 string) (*v1.Secret, error) {
	fake.getServiceAccountSecretMutex.Lock()
	ret, specificReturn := fake.getServiceAccountSecretReturnsOnCall[len(fake.getServiceAccountSecretArgsForCall)]
	fake.getServiceAccountSecretArgsForCall = append(fake.getServiceAccountSecretArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetServiceAccountSecretStub
	fakeReturns := fake.getServiceAccountSecretReturns
	fake.recordInvocation("GetServiceAccountSecret", []interface{}{arg1, arg2, arg3})
	fake.getServiceAccountSecretMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetServiceAccountSecretCallCount() int {
	fake.getServiceAccountSecretMutex.RLock()
	defer fake.getServiceAccountSecretMutex.RUnlock()
	return len(fake.getServiceAccountSecretArgsForCall)
}

func (fake *FakeRepository) GetServiceAccountSecretCalls(stub func(context.Context, string, string) (*v1.Secret, error)) {
	fake.getServiceAccountSecretMutex.Lock()
	defer fake.getServiceAccountSecretMutex.Unlock()
	fake.GetServiceAccountSecretStub = stub
}

func (fake *FakeRepository) GetServiceAccountSecretArgsForCall(i int) (context.Context, string, string) {
	fake.getServiceAccountSecretMutex.RLock()
	defer fake.getServiceAccountSecretMutex.RUnlock()
	argsForCall := fake.getServiceAccountSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetServiceAccountSecretReturns(result1 *v1.Secret, result2 error) {
	fake.getServiceAccountSecretMutex.Lock()
	defer fake.getServiceAccountSecretMutex.Unlock()
	fake.GetServiceAccountSecretStub = nil
	fake.getServiceAccountSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetServiceAccountSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.getServiceAccountSecretMutex.Lock()
	defer fake.getServiceAccountSecretMutex.Unlock()
	fake.GetServiceAccountSecretStub = nil
	if fake.getServiceAccountSecretReturnsOnCall == nil {
		fake.getServiceAccountSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.getServiceAccountSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChain(arg1 context.Context, arg2 string) (*v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainMutex.Lock()
	ret, specificReturn := fake.getSupplyChainReturnsOnCall[len(fake.getSupplyChainArgsForCall)]
	fake.getSupplyChainArgsForCall = append(fake.getSupplyChainArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSupplyChainStub
	fakeReturns := fake.getSupplyChainReturns
	fake.recordInvocation("GetSupplyChain", []interface{}{arg1, arg2})
	fake.getSupplyChainMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainCallCount() int {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	return len(fake.getSupplyChainArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainCalls(stub func(context.Context, string) (*v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = stub
}

func (fake *FakeRepository) GetSupplyChainArgsForCall(i int) (context.Context, string) {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	argsForCall := fake.getSupplyChainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetSupplyChainReturns(result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	fake.getSupplyChainReturns = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainReturnsOnCall(i int, result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	if fake.getSupplyChainReturnsOnCall == nil {
		fake.getSupplyChainReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkload(arg1 context.Context, arg2 *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	ret, specificReturn := fake.getSupplyChainsForWorkloadReturnsOnCall[len(fake.getSupplyChainsForWorkloadArgsForCall)]
	fake.getSupplyChainsForWorkloadArgsForCall = append(fake.getSupplyChainsForWorkloadArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.Workload
	}{arg1, arg2})
	stub := fake.GetSupplyChainsForWorkloadStub
	fakeReturns := fake.getSupplyChainsForWorkloadReturns
	fake.recordInvocation("GetSupplyChainsForWorkload", []interface{}{arg1, arg2})
	fake.getSupplyChainsForWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCallCount() int {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	return len(fake.getSupplyChainsForWorkloadArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCalls(stub func(context.Context, *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = stub
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadArgsForCall(i int) (context.Context, *v1alpha1.Workload) {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	argsForCall := fake.getSupplyChainsForWorkloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturns(result1 []*v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	fake.getSupplyChainsForWorkloadReturns = struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturnsOnCall(i int, result1 []*v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	if fake.getSupplyChainsForWorkloadReturnsOnCall == nil {
		fake.getSupplyChainsForWorkloadReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainsForWorkloadReturnsOnCall[i] = struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetUnstructured(arg1 context.Context, arg2 string, arg3 string) (*unstructured.Unstructured, error) {
	fake.getUnstructuredMutex.Lock()
	ret, specificReturn := fake.getUnstructuredReturnsOnCall[len(fake.getUnstructuredArgsForCall)]
	fake.getUnstructuredArgsForCall = append(fake.getUnstructuredArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetUnstructuredStub
	fakeReturns := fake.getUnstructuredReturns
	fake.recordInvocation("GetUnstructured", []interface{}{arg1, arg2, arg3})
	fake.getUnstructuredMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetUnstructuredCallCount() int {
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	return len(fake.getUnstructuredArgsForCall)
}

func (fake *FakeRepository) GetUnstructuredCalls(stub func(context.Context, string, string) (*unstructured.Unstructured, error)) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = stub
}

func (fake *FakeRepository) GetUnstructuredArgsForCall(i int) (context.Context, string, string) {
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	argsForCall := fake.getUnstructuredArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetUnstructuredReturns(result1 *unstructured.Unstructured, result2 error) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = nil
	fake.getUnstructuredReturns = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetUnstructuredReturnsOnCall(i int, result1 *unstructured.Unstructured, result2 error) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = nil
	if fake.getUnstructuredReturnsOnCall == nil {
		fake.getUnstructuredReturnsOnCall = make(map[int]struct {
			result1 *unstructured.Unstructured
			result2 error
		})
	}
	fake.getUnstructuredReturnsOnCall[i] = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkload(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Workload, error) {
	fake.getWorkloadMutex.Lock()
	ret, specificReturn := fake.getWorkloadReturnsOnCall[len(fake.getWorkloadArgsForCall)]
	fake.getWorkloadArgsForCall = append(fake.getWorkloadArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetWorkloadStub
	fakeReturns := fake.getWorkloadReturns
	fake.recordInvocation("GetWorkload", []interface{}{arg1, arg2, arg3})
	fake.getWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetWorkloadCallCount() int {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	return len(fake.getWorkloadArgsForCall)
}

func (fake *FakeRepository) GetWorkloadCalls(stub func(context.Context, string, string) (*v1alpha1.Workload, error)) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = stub
}

func (fake *FakeRepository) GetWorkloadArgsForCall(i int) (context.Context, string, string) {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	argsForCall := fake.getWorkloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetWorkloadReturns(result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	fake.getWorkloadReturns = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkloadReturnsOnCall(i int, result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	if fake.getWorkloadReturnsOnCall == nil {
		fake.getWorkloadReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Workload
			result2 error
		})
	}
	fake.getWorkloadReturnsOnCall[i] = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructured(arg1 context.Context, arg2 schema.GroupVersionKind, arg3 string, arg4 map[string]string) ([]*unstructured.Unstructured, error) {
	fake.listUnstructuredMutex.Lock()
	ret, specificReturn := fake.listUnstructuredReturnsOnCall[len(fake.listUnstructuredArgsForCall)]
	fake.listUnstructuredArgsForCall = append(fake.listUnstructuredArgsForCall, struct {
		arg1 context.Context
		arg2 schema.GroupVersionKind
		arg3 string
		arg4 map[string]string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListUnstructuredStub
	fakeReturns := fake.listUnstructuredReturns
	fake.recordInvocation("ListUnstructured", []interface{}{arg1, arg2, arg3, arg4})
	fake.listUnstructuredMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ListUnstructuredCallCount() int {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	return len(fake.listUnstructuredArgsForCall)
}

func (fake *FakeRepository) ListUnstructuredCalls(stub func(context.Context, schema.GroupVersionKind, string, map[string]string) ([]*unstructured.Unstructured, error)) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = stub
}

func (fake *FakeRepository) ListUnstructuredArgsForCall(i int) (context.Context, schema.GroupVersionKind, string, map[string]string) {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	argsForCall := fake.listUnstructuredArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeRepository) ListUnstructuredReturns(result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	fake.listUnstructuredReturns = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructuredReturnsOnCall(i int, result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	if fake.listUnstructuredReturnsOnCall == nil {
		fake.listUnstructuredReturnsOnCall = make(map[int]struct {
			result1 []*unstructured.Unstructured
			result2 error
		})
	}
	fake.listUnstructuredReturnsOnCall[i] = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) StatusUpdate(arg1 context.Context, arg2 client.Object) error {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
	}{arg1, arg2})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1, arg2})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakeRepository) StatusUpdateCalls(stub func(context.Context, client.Object) error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakeRepository) StatusUpdateArgsForCall(i int) (context.Context, client.Object) {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) StatusUpdateReturns(result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) StatusUpdateReturnsOnCall(i int, result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	fake.getServiceAccountSecretMutex.RLock()
	defer fake.getServiceAccountSecretMutex.RUnlock()
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.Repository = new(FakeRepository)

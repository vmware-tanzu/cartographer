// Code generated by counterfeiter. DO NOT EDIT.
package repositoryfakes

import (
	"context"
	"sync"

	"github.com/vmware-tanzu/cartographer/pkg/apis/v1alpha1"
	"github.com/vmware-tanzu/cartographer/pkg/repository"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type FakeRepository struct {
	DeleteStub        func(context.Context, *unstructured.Unstructured) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureImmutableObjectExistsOnClusterStub        func(context.Context, *unstructured.Unstructured, map[string]string) error
	ensureImmutableObjectExistsOnClusterMutex       sync.RWMutex
	ensureImmutableObjectExistsOnClusterArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
		arg3 map[string]string
	}
	ensureImmutableObjectExistsOnClusterReturns struct {
		result1 error
	}
	ensureImmutableObjectExistsOnClusterReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureMutableObjectExistsOnClusterStub        func(context.Context, *unstructured.Unstructured) error
	ensureMutableObjectExistsOnClusterMutex       sync.RWMutex
	ensureMutableObjectExistsOnClusterArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}
	ensureMutableObjectExistsOnClusterReturns struct {
		result1 error
	}
	ensureMutableObjectExistsOnClusterReturnsOnCall map[int]struct {
		result1 error
	}
	GetDeliverableStub        func(context.Context, string, string) (*v1alpha1.Deliverable, error)
	getDeliverableMutex       sync.RWMutex
	getDeliverableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getDeliverableReturns struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	getDeliverableReturnsOnCall map[int]struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	GetDeliveriesForDeliverableStub        func(context.Context, *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error)
	getDeliveriesForDeliverableMutex       sync.RWMutex
	getDeliveriesForDeliverableArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.Deliverable
	}
	getDeliveriesForDeliverableReturns struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveriesForDeliverableReturnsOnCall map[int]struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}
	GetDeliveryStub        func(context.Context, string) (*v1alpha1.ClusterDelivery, error)
	getDeliveryMutex       sync.RWMutex
	getDeliveryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDeliveryReturns struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveryReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	GetRESTMapperStub        func() meta.RESTMapper
	getRESTMapperMutex       sync.RWMutex
	getRESTMapperArgsForCall []struct {
	}
	getRESTMapperReturns struct {
		result1 meta.RESTMapper
	}
	getRESTMapperReturnsOnCall map[int]struct {
		result1 meta.RESTMapper
	}
	GetRunTemplateStub        func(context.Context, v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error)
	getRunTemplateMutex       sync.RWMutex
	getRunTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 v1alpha1.TemplateReference
	}
	getRunTemplateReturns struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}
	getRunTemplateReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}
	GetRunnableStub        func(context.Context, string, string) (*v1alpha1.Runnable, error)
	getRunnableMutex       sync.RWMutex
	getRunnableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getRunnableReturns struct {
		result1 *v1alpha1.Runnable
		result2 error
	}
	getRunnableReturnsOnCall map[int]struct {
		result1 *v1alpha1.Runnable
		result2 error
	}
	GetSchemeStub        func() *runtime.Scheme
	getSchemeMutex       sync.RWMutex
	getSchemeArgsForCall []struct {
	}
	getSchemeReturns struct {
		result1 *runtime.Scheme
	}
	getSchemeReturnsOnCall map[int]struct {
		result1 *runtime.Scheme
	}
	GetServiceAccountStub        func(context.Context, string, string) (*v1.ServiceAccount, error)
	getServiceAccountMutex       sync.RWMutex
	getServiceAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getServiceAccountReturns struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	getServiceAccountReturnsOnCall map[int]struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	GetSupplyChainStub        func(context.Context, string) (*v1alpha1.ClusterSupplyChain, error)
	getSupplyChainMutex       sync.RWMutex
	getSupplyChainArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getSupplyChainReturns struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetSupplyChainsForWorkloadStub        func(context.Context, *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error)
	getSupplyChainsForWorkloadMutex       sync.RWMutex
	getSupplyChainsForWorkloadArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.Workload
	}
	getSupplyChainsForWorkloadReturns struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainsForWorkloadReturnsOnCall map[int]struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetTemplateStub        func(context.Context, string, string) (client.Object, error)
	getTemplateMutex       sync.RWMutex
	getTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getTemplateReturns struct {
		result1 client.Object
		result2 error
	}
	getTemplateReturnsOnCall map[int]struct {
		result1 client.Object
		result2 error
	}
	GetUnstructuredStub        func(context.Context, *unstructured.Unstructured) (*unstructured.Unstructured, error)
	getUnstructuredMutex       sync.RWMutex
	getUnstructuredArgsForCall []struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}
	getUnstructuredReturns struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	getUnstructuredReturnsOnCall map[int]struct {
		result1 *unstructured.Unstructured
		result2 error
	}
	GetWorkloadStub        func(context.Context, string, string) (*v1alpha1.Workload, error)
	getWorkloadMutex       sync.RWMutex
	getWorkloadArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getWorkloadReturns struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	getWorkloadReturnsOnCall map[int]struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	ListUnstructuredStub        func(context.Context, schema.GroupVersionKind, string, map[string]string) ([]*unstructured.Unstructured, error)
	listUnstructuredMutex       sync.RWMutex
	listUnstructuredArgsForCall []struct {
		arg1 context.Context
		arg2 schema.GroupVersionKind
		arg3 string
		arg4 map[string]string
	}
	listUnstructuredReturns struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	listUnstructuredReturnsOnCall map[int]struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	StatusUpdateStub        func(context.Context, client.Object) error
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
	}
	statusUpdateReturns struct {
		result1 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepository) Delete(arg1 context.Context, arg2 *unstructured.Unstructured) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}{arg1, arg2})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeRepository) DeleteCalls(stub func(context.Context, *unstructured.Unstructured) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeRepository) DeleteArgsForCall(i int) (context.Context, *unstructured.Unstructured) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnCluster(arg1 context.Context, arg2 *unstructured.Unstructured, arg3 map[string]string) error {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	ret, specificReturn := fake.ensureImmutableObjectExistsOnClusterReturnsOnCall[len(fake.ensureImmutableObjectExistsOnClusterArgsForCall)]
	fake.ensureImmutableObjectExistsOnClusterArgsForCall = append(fake.ensureImmutableObjectExistsOnClusterArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.EnsureImmutableObjectExistsOnClusterStub
	fakeReturns := fake.ensureImmutableObjectExistsOnClusterReturns
	fake.recordInvocation("EnsureImmutableObjectExistsOnCluster", []interface{}{arg1, arg2, arg3})
	fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterCallCount() int {
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	return len(fake.ensureImmutableObjectExistsOnClusterArgsForCall)
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterCalls(stub func(context.Context, *unstructured.Unstructured, map[string]string) error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = stub
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterArgsForCall(i int) (context.Context, *unstructured.Unstructured, map[string]string) {
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	argsForCall := fake.ensureImmutableObjectExistsOnClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterReturns(result1 error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = nil
	fake.ensureImmutableObjectExistsOnClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureImmutableObjectExistsOnClusterReturnsOnCall(i int, result1 error) {
	fake.ensureImmutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureImmutableObjectExistsOnClusterStub = nil
	if fake.ensureImmutableObjectExistsOnClusterReturnsOnCall == nil {
		fake.ensureImmutableObjectExistsOnClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureImmutableObjectExistsOnClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnCluster(arg1 context.Context, arg2 *unstructured.Unstructured) error {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	ret, specificReturn := fake.ensureMutableObjectExistsOnClusterReturnsOnCall[len(fake.ensureMutableObjectExistsOnClusterArgsForCall)]
	fake.ensureMutableObjectExistsOnClusterArgsForCall = append(fake.ensureMutableObjectExistsOnClusterArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}{arg1, arg2})
	stub := fake.EnsureMutableObjectExistsOnClusterStub
	fakeReturns := fake.ensureMutableObjectExistsOnClusterReturns
	fake.recordInvocation("EnsureMutableObjectExistsOnCluster", []interface{}{arg1, arg2})
	fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterCallCount() int {
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	return len(fake.ensureMutableObjectExistsOnClusterArgsForCall)
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterCalls(stub func(context.Context, *unstructured.Unstructured) error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = stub
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterArgsForCall(i int) (context.Context, *unstructured.Unstructured) {
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	argsForCall := fake.ensureMutableObjectExistsOnClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterReturns(result1 error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = nil
	fake.ensureMutableObjectExistsOnClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureMutableObjectExistsOnClusterReturnsOnCall(i int, result1 error) {
	fake.ensureMutableObjectExistsOnClusterMutex.Lock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.Unlock()
	fake.EnsureMutableObjectExistsOnClusterStub = nil
	if fake.ensureMutableObjectExistsOnClusterReturnsOnCall == nil {
		fake.ensureMutableObjectExistsOnClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureMutableObjectExistsOnClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetDeliverable(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Deliverable, error) {
	fake.getDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliverableReturnsOnCall[len(fake.getDeliverableArgsForCall)]
	fake.getDeliverableArgsForCall = append(fake.getDeliverableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetDeliverableStub
	fakeReturns := fake.getDeliverableReturns
	fake.recordInvocation("GetDeliverable", []interface{}{arg1, arg2, arg3})
	fake.getDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliverableCallCount() int {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	return len(fake.getDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliverableCalls(stub func(context.Context, string, string) (*v1alpha1.Deliverable, error)) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliverableArgsForCall(i int) (context.Context, string, string) {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliverableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetDeliverableReturns(result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	fake.getDeliverableReturns = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliverableReturnsOnCall(i int, result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	if fake.getDeliverableReturnsOnCall == nil {
		fake.getDeliverableReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Deliverable
			result2 error
		})
	}
	fake.getDeliverableReturnsOnCall[i] = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverable(arg1 context.Context, arg2 *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliveriesForDeliverableReturnsOnCall[len(fake.getDeliveriesForDeliverableArgsForCall)]
	fake.getDeliveriesForDeliverableArgsForCall = append(fake.getDeliveriesForDeliverableArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.Deliverable
	}{arg1, arg2})
	stub := fake.GetDeliveriesForDeliverableStub
	fakeReturns := fake.getDeliveriesForDeliverableReturns
	fake.recordInvocation("GetDeliveriesForDeliverable", []interface{}{arg1, arg2})
	fake.getDeliveriesForDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCallCount() int {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	return len(fake.getDeliveriesForDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCalls(stub func(context.Context, *v1alpha1.Deliverable) ([]*v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliveriesForDeliverableArgsForCall(i int) (context.Context, *v1alpha1.Deliverable) {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliveriesForDeliverableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturns(result1 []*v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	fake.getDeliveriesForDeliverableReturns = struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturnsOnCall(i int, result1 []*v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	if fake.getDeliveriesForDeliverableReturnsOnCall == nil {
		fake.getDeliveriesForDeliverableReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveriesForDeliverableReturnsOnCall[i] = struct {
		result1 []*v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDelivery(arg1 context.Context, arg2 string) (*v1alpha1.ClusterDelivery, error) {
	fake.getDeliveryMutex.Lock()
	ret, specificReturn := fake.getDeliveryReturnsOnCall[len(fake.getDeliveryArgsForCall)]
	fake.getDeliveryArgsForCall = append(fake.getDeliveryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDeliveryStub
	fakeReturns := fake.getDeliveryReturns
	fake.recordInvocation("GetDelivery", []interface{}{arg1, arg2})
	fake.getDeliveryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveryCallCount() int {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	return len(fake.getDeliveryArgsForCall)
}

func (fake *FakeRepository) GetDeliveryCalls(stub func(context.Context, string) (*v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = stub
}

func (fake *FakeRepository) GetDeliveryArgsForCall(i int) (context.Context, string) {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	argsForCall := fake.getDeliveryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliveryReturns(result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	fake.getDeliveryReturns = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryReturnsOnCall(i int, result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	if fake.getDeliveryReturnsOnCall == nil {
		fake.getDeliveryReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveryReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRESTMapper() meta.RESTMapper {
	fake.getRESTMapperMutex.Lock()
	ret, specificReturn := fake.getRESTMapperReturnsOnCall[len(fake.getRESTMapperArgsForCall)]
	fake.getRESTMapperArgsForCall = append(fake.getRESTMapperArgsForCall, struct {
	}{})
	stub := fake.GetRESTMapperStub
	fakeReturns := fake.getRESTMapperReturns
	fake.recordInvocation("GetRESTMapper", []interface{}{})
	fake.getRESTMapperMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) GetRESTMapperCallCount() int {
	fake.getRESTMapperMutex.RLock()
	defer fake.getRESTMapperMutex.RUnlock()
	return len(fake.getRESTMapperArgsForCall)
}

func (fake *FakeRepository) GetRESTMapperCalls(stub func() meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = stub
}

func (fake *FakeRepository) GetRESTMapperReturns(result1 meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = nil
	fake.getRESTMapperReturns = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *FakeRepository) GetRESTMapperReturnsOnCall(i int, result1 meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = nil
	if fake.getRESTMapperReturnsOnCall == nil {
		fake.getRESTMapperReturnsOnCall = make(map[int]struct {
			result1 meta.RESTMapper
		})
	}
	fake.getRESTMapperReturnsOnCall[i] = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *FakeRepository) GetRunTemplate(arg1 context.Context, arg2 v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error) {
	fake.getRunTemplateMutex.Lock()
	ret, specificReturn := fake.getRunTemplateReturnsOnCall[len(fake.getRunTemplateArgsForCall)]
	fake.getRunTemplateArgsForCall = append(fake.getRunTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 v1alpha1.TemplateReference
	}{arg1, arg2})
	stub := fake.GetRunTemplateStub
	fakeReturns := fake.getRunTemplateReturns
	fake.recordInvocation("GetRunTemplate", []interface{}{arg1, arg2})
	fake.getRunTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetRunTemplateCallCount() int {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	return len(fake.getRunTemplateArgsForCall)
}

func (fake *FakeRepository) GetRunTemplateCalls(stub func(context.Context, v1alpha1.TemplateReference) (*v1alpha1.ClusterRunTemplate, error)) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = stub
}

func (fake *FakeRepository) GetRunTemplateArgsForCall(i int) (context.Context, v1alpha1.TemplateReference) {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	argsForCall := fake.getRunTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetRunTemplateReturns(result1 *v1alpha1.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	fake.getRunTemplateReturns = struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunTemplateReturnsOnCall(i int, result1 *v1alpha1.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	if fake.getRunTemplateReturnsOnCall == nil {
		fake.getRunTemplateReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterRunTemplate
			result2 error
		})
	}
	fake.getRunTemplateReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunnable(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Runnable, error) {
	fake.getRunnableMutex.Lock()
	ret, specificReturn := fake.getRunnableReturnsOnCall[len(fake.getRunnableArgsForCall)]
	fake.getRunnableArgsForCall = append(fake.getRunnableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetRunnableStub
	fakeReturns := fake.getRunnableReturns
	fake.recordInvocation("GetRunnable", []interface{}{arg1, arg2, arg3})
	fake.getRunnableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetRunnableCallCount() int {
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	return len(fake.getRunnableArgsForCall)
}

func (fake *FakeRepository) GetRunnableCalls(stub func(context.Context, string, string) (*v1alpha1.Runnable, error)) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = stub
}

func (fake *FakeRepository) GetRunnableArgsForCall(i int) (context.Context, string, string) {
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	argsForCall := fake.getRunnableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetRunnableReturns(result1 *v1alpha1.Runnable, result2 error) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = nil
	fake.getRunnableReturns = struct {
		result1 *v1alpha1.Runnable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunnableReturnsOnCall(i int, result1 *v1alpha1.Runnable, result2 error) {
	fake.getRunnableMutex.Lock()
	defer fake.getRunnableMutex.Unlock()
	fake.GetRunnableStub = nil
	if fake.getRunnableReturnsOnCall == nil {
		fake.getRunnableReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Runnable
			result2 error
		})
	}
	fake.getRunnableReturnsOnCall[i] = struct {
		result1 *v1alpha1.Runnable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetScheme() *runtime.Scheme {
	fake.getSchemeMutex.Lock()
	ret, specificReturn := fake.getSchemeReturnsOnCall[len(fake.getSchemeArgsForCall)]
	fake.getSchemeArgsForCall = append(fake.getSchemeArgsForCall, struct {
	}{})
	stub := fake.GetSchemeStub
	fakeReturns := fake.getSchemeReturns
	fake.recordInvocation("GetScheme", []interface{}{})
	fake.getSchemeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) GetSchemeCallCount() int {
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	return len(fake.getSchemeArgsForCall)
}

func (fake *FakeRepository) GetSchemeCalls(stub func() *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = stub
}

func (fake *FakeRepository) GetSchemeReturns(result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	fake.getSchemeReturns = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetSchemeReturnsOnCall(i int, result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	if fake.getSchemeReturnsOnCall == nil {
		fake.getSchemeReturnsOnCall = make(map[int]struct {
			result1 *runtime.Scheme
		})
	}
	fake.getSchemeReturnsOnCall[i] = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetServiceAccount(arg1 context.Context, arg2 string, arg3 string) (*v1.ServiceAccount, error) {
	fake.getServiceAccountMutex.Lock()
	ret, specificReturn := fake.getServiceAccountReturnsOnCall[len(fake.getServiceAccountArgsForCall)]
	fake.getServiceAccountArgsForCall = append(fake.getServiceAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetServiceAccountStub
	fakeReturns := fake.getServiceAccountReturns
	fake.recordInvocation("GetServiceAccount", []interface{}{arg1, arg2, arg3})
	fake.getServiceAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetServiceAccountCallCount() int {
	fake.getServiceAccountMutex.RLock()
	defer fake.getServiceAccountMutex.RUnlock()
	return len(fake.getServiceAccountArgsForCall)
}

func (fake *FakeRepository) GetServiceAccountCalls(stub func(context.Context, string, string) (*v1.ServiceAccount, error)) {
	fake.getServiceAccountMutex.Lock()
	defer fake.getServiceAccountMutex.Unlock()
	fake.GetServiceAccountStub = stub
}

func (fake *FakeRepository) GetServiceAccountArgsForCall(i int) (context.Context, string, string) {
	fake.getServiceAccountMutex.RLock()
	defer fake.getServiceAccountMutex.RUnlock()
	argsForCall := fake.getServiceAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetServiceAccountReturns(result1 *v1.ServiceAccount, result2 error) {
	fake.getServiceAccountMutex.Lock()
	defer fake.getServiceAccountMutex.Unlock()
	fake.GetServiceAccountStub = nil
	fake.getServiceAccountReturns = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetServiceAccountReturnsOnCall(i int, result1 *v1.ServiceAccount, result2 error) {
	fake.getServiceAccountMutex.Lock()
	defer fake.getServiceAccountMutex.Unlock()
	fake.GetServiceAccountStub = nil
	if fake.getServiceAccountReturnsOnCall == nil {
		fake.getServiceAccountReturnsOnCall = make(map[int]struct {
			result1 *v1.ServiceAccount
			result2 error
		})
	}
	fake.getServiceAccountReturnsOnCall[i] = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChain(arg1 context.Context, arg2 string) (*v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainMutex.Lock()
	ret, specificReturn := fake.getSupplyChainReturnsOnCall[len(fake.getSupplyChainArgsForCall)]
	fake.getSupplyChainArgsForCall = append(fake.getSupplyChainArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSupplyChainStub
	fakeReturns := fake.getSupplyChainReturns
	fake.recordInvocation("GetSupplyChain", []interface{}{arg1, arg2})
	fake.getSupplyChainMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainCallCount() int {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	return len(fake.getSupplyChainArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainCalls(stub func(context.Context, string) (*v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = stub
}

func (fake *FakeRepository) GetSupplyChainArgsForCall(i int) (context.Context, string) {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	argsForCall := fake.getSupplyChainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetSupplyChainReturns(result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	fake.getSupplyChainReturns = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainReturnsOnCall(i int, result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	if fake.getSupplyChainReturnsOnCall == nil {
		fake.getSupplyChainReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkload(arg1 context.Context, arg2 *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	ret, specificReturn := fake.getSupplyChainsForWorkloadReturnsOnCall[len(fake.getSupplyChainsForWorkloadArgsForCall)]
	fake.getSupplyChainsForWorkloadArgsForCall = append(fake.getSupplyChainsForWorkloadArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.Workload
	}{arg1, arg2})
	stub := fake.GetSupplyChainsForWorkloadStub
	fakeReturns := fake.getSupplyChainsForWorkloadReturns
	fake.recordInvocation("GetSupplyChainsForWorkload", []interface{}{arg1, arg2})
	fake.getSupplyChainsForWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCallCount() int {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	return len(fake.getSupplyChainsForWorkloadArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCalls(stub func(context.Context, *v1alpha1.Workload) ([]*v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = stub
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadArgsForCall(i int) (context.Context, *v1alpha1.Workload) {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	argsForCall := fake.getSupplyChainsForWorkloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturns(result1 []*v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	fake.getSupplyChainsForWorkloadReturns = struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturnsOnCall(i int, result1 []*v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	if fake.getSupplyChainsForWorkloadReturnsOnCall == nil {
		fake.getSupplyChainsForWorkloadReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainsForWorkloadReturnsOnCall[i] = struct {
		result1 []*v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetTemplate(arg1 context.Context, arg2 string, arg3 string) (client.Object, error) {
	fake.getTemplateMutex.Lock()
	ret, specificReturn := fake.getTemplateReturnsOnCall[len(fake.getTemplateArgsForCall)]
	fake.getTemplateArgsForCall = append(fake.getTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetTemplateStub
	fakeReturns := fake.getTemplateReturns
	fake.recordInvocation("GetTemplate", []interface{}{arg1, arg2, arg3})
	fake.getTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetTemplateCallCount() int {
	fake.getTemplateMutex.RLock()
	defer fake.getTemplateMutex.RUnlock()
	return len(fake.getTemplateArgsForCall)
}

func (fake *FakeRepository) GetTemplateCalls(stub func(context.Context, string, string) (client.Object, error)) {
	fake.getTemplateMutex.Lock()
	defer fake.getTemplateMutex.Unlock()
	fake.GetTemplateStub = stub
}

func (fake *FakeRepository) GetTemplateArgsForCall(i int) (context.Context, string, string) {
	fake.getTemplateMutex.RLock()
	defer fake.getTemplateMutex.RUnlock()
	argsForCall := fake.getTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetTemplateReturns(result1 client.Object, result2 error) {
	fake.getTemplateMutex.Lock()
	defer fake.getTemplateMutex.Unlock()
	fake.GetTemplateStub = nil
	fake.getTemplateReturns = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetTemplateReturnsOnCall(i int, result1 client.Object, result2 error) {
	fake.getTemplateMutex.Lock()
	defer fake.getTemplateMutex.Unlock()
	fake.GetTemplateStub = nil
	if fake.getTemplateReturnsOnCall == nil {
		fake.getTemplateReturnsOnCall = make(map[int]struct {
			result1 client.Object
			result2 error
		})
	}
	fake.getTemplateReturnsOnCall[i] = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetUnstructured(arg1 context.Context, arg2 *unstructured.Unstructured) (*unstructured.Unstructured, error) {
	fake.getUnstructuredMutex.Lock()
	ret, specificReturn := fake.getUnstructuredReturnsOnCall[len(fake.getUnstructuredArgsForCall)]
	fake.getUnstructuredArgsForCall = append(fake.getUnstructuredArgsForCall, struct {
		arg1 context.Context
		arg2 *unstructured.Unstructured
	}{arg1, arg2})
	stub := fake.GetUnstructuredStub
	fakeReturns := fake.getUnstructuredReturns
	fake.recordInvocation("GetUnstructured", []interface{}{arg1, arg2})
	fake.getUnstructuredMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetUnstructuredCallCount() int {
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	return len(fake.getUnstructuredArgsForCall)
}

func (fake *FakeRepository) GetUnstructuredCalls(stub func(context.Context, *unstructured.Unstructured) (*unstructured.Unstructured, error)) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = stub
}

func (fake *FakeRepository) GetUnstructuredArgsForCall(i int) (context.Context, *unstructured.Unstructured) {
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	argsForCall := fake.getUnstructuredArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetUnstructuredReturns(result1 *unstructured.Unstructured, result2 error) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = nil
	fake.getUnstructuredReturns = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetUnstructuredReturnsOnCall(i int, result1 *unstructured.Unstructured, result2 error) {
	fake.getUnstructuredMutex.Lock()
	defer fake.getUnstructuredMutex.Unlock()
	fake.GetUnstructuredStub = nil
	if fake.getUnstructuredReturnsOnCall == nil {
		fake.getUnstructuredReturnsOnCall = make(map[int]struct {
			result1 *unstructured.Unstructured
			result2 error
		})
	}
	fake.getUnstructuredReturnsOnCall[i] = struct {
		result1 *unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkload(arg1 context.Context, arg2 string, arg3 string) (*v1alpha1.Workload, error) {
	fake.getWorkloadMutex.Lock()
	ret, specificReturn := fake.getWorkloadReturnsOnCall[len(fake.getWorkloadArgsForCall)]
	fake.getWorkloadArgsForCall = append(fake.getWorkloadArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetWorkloadStub
	fakeReturns := fake.getWorkloadReturns
	fake.recordInvocation("GetWorkload", []interface{}{arg1, arg2, arg3})
	fake.getWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetWorkloadCallCount() int {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	return len(fake.getWorkloadArgsForCall)
}

func (fake *FakeRepository) GetWorkloadCalls(stub func(context.Context, string, string) (*v1alpha1.Workload, error)) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = stub
}

func (fake *FakeRepository) GetWorkloadArgsForCall(i int) (context.Context, string, string) {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	argsForCall := fake.getWorkloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRepository) GetWorkloadReturns(result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	fake.getWorkloadReturns = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkloadReturnsOnCall(i int, result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	if fake.getWorkloadReturnsOnCall == nil {
		fake.getWorkloadReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Workload
			result2 error
		})
	}
	fake.getWorkloadReturnsOnCall[i] = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructured(arg1 context.Context, arg2 schema.GroupVersionKind, arg3 string, arg4 map[string]string) ([]*unstructured.Unstructured, error) {
	fake.listUnstructuredMutex.Lock()
	ret, specificReturn := fake.listUnstructuredReturnsOnCall[len(fake.listUnstructuredArgsForCall)]
	fake.listUnstructuredArgsForCall = append(fake.listUnstructuredArgsForCall, struct {
		arg1 context.Context
		arg2 schema.GroupVersionKind
		arg3 string
		arg4 map[string]string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListUnstructuredStub
	fakeReturns := fake.listUnstructuredReturns
	fake.recordInvocation("ListUnstructured", []interface{}{arg1, arg2, arg3, arg4})
	fake.listUnstructuredMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ListUnstructuredCallCount() int {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	return len(fake.listUnstructuredArgsForCall)
}

func (fake *FakeRepository) ListUnstructuredCalls(stub func(context.Context, schema.GroupVersionKind, string, map[string]string) ([]*unstructured.Unstructured, error)) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = stub
}

func (fake *FakeRepository) ListUnstructuredArgsForCall(i int) (context.Context, schema.GroupVersionKind, string, map[string]string) {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	argsForCall := fake.listUnstructuredArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeRepository) ListUnstructuredReturns(result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	fake.listUnstructuredReturns = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructuredReturnsOnCall(i int, result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	if fake.listUnstructuredReturnsOnCall == nil {
		fake.listUnstructuredReturnsOnCall = make(map[int]struct {
			result1 []*unstructured.Unstructured
			result2 error
		})
	}
	fake.listUnstructuredReturnsOnCall[i] = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) StatusUpdate(arg1 context.Context, arg2 client.Object) error {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
	}{arg1, arg2})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1, arg2})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakeRepository) StatusUpdateCalls(stub func(context.Context, client.Object) error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakeRepository) StatusUpdateArgsForCall(i int) (context.Context, client.Object) {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) StatusUpdateReturns(result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) StatusUpdateReturnsOnCall(i int, result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.ensureImmutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureImmutableObjectExistsOnClusterMutex.RUnlock()
	fake.ensureMutableObjectExistsOnClusterMutex.RLock()
	defer fake.ensureMutableObjectExistsOnClusterMutex.RUnlock()
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	fake.getRESTMapperMutex.RLock()
	defer fake.getRESTMapperMutex.RUnlock()
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	fake.getRunnableMutex.RLock()
	defer fake.getRunnableMutex.RUnlock()
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	fake.getServiceAccountMutex.RLock()
	defer fake.getServiceAccountMutex.RUnlock()
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	fake.getTemplateMutex.RLock()
	defer fake.getTemplateMutex.RUnlock()
	fake.getUnstructuredMutex.RLock()
	defer fake.getUnstructuredMutex.RUnlock()
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.Repository = new(FakeRepository)

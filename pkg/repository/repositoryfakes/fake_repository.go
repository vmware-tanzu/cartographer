// Code generated by counterfeiter. DO NOT EDIT.
package repositoryfakes

import (
	"sync"

	"github.com/vmware-tanzu/cartographer/pkg/apis/v1alpha1"
	"github.com/vmware-tanzu/cartographer/pkg/repository"
	"github.com/vmware-tanzu/cartographer/pkg/templates"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type FakeRepository struct {
	EnsureObjectExistsOnClusterStub        func(*unstructured.Unstructured, bool) error
	ensureObjectExistsOnClusterMutex       sync.RWMutex
	ensureObjectExistsOnClusterArgsForCall []struct {
		arg1 *unstructured.Unstructured
		arg2 bool
	}
	ensureObjectExistsOnClusterReturns struct {
		result1 error
	}
	ensureObjectExistsOnClusterReturnsOnCall map[int]struct {
		result1 error
	}
	GetClusterTemplateStub        func(v1alpha1.ClusterTemplateReference) (templates.Template, error)
	getClusterTemplateMutex       sync.RWMutex
	getClusterTemplateArgsForCall []struct {
		arg1 v1alpha1.ClusterTemplateReference
	}
	getClusterTemplateReturns struct {
		result1 templates.Template
		result2 error
	}
	getClusterTemplateReturnsOnCall map[int]struct {
		result1 templates.Template
		result2 error
	}
	GetDeliverableStub        func(string, string) (*v1alpha1.Deliverable, error)
	getDeliverableMutex       sync.RWMutex
	getDeliverableArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getDeliverableReturns struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	getDeliverableReturnsOnCall map[int]struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}
	GetDeliveriesForDeliverableStub        func(*v1alpha1.Deliverable) ([]v1alpha1.ClusterDelivery, error)
	getDeliveriesForDeliverableMutex       sync.RWMutex
	getDeliveriesForDeliverableArgsForCall []struct {
		arg1 *v1alpha1.Deliverable
	}
	getDeliveriesForDeliverableReturns struct {
		result1 []v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveriesForDeliverableReturnsOnCall map[int]struct {
		result1 []v1alpha1.ClusterDelivery
		result2 error
	}
	GetDeliveryStub        func(string) (*v1alpha1.ClusterDelivery, error)
	getDeliveryMutex       sync.RWMutex
	getDeliveryArgsForCall []struct {
		arg1 string
	}
	getDeliveryReturns struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	getDeliveryReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}
	GetDeliveryClusterTemplateStub        func(v1alpha1.DeliveryClusterTemplateReference) (templates.Template, error)
	getDeliveryClusterTemplateMutex       sync.RWMutex
	getDeliveryClusterTemplateArgsForCall []struct {
		arg1 v1alpha1.DeliveryClusterTemplateReference
	}
	getDeliveryClusterTemplateReturns struct {
		result1 templates.Template
		result2 error
	}
	getDeliveryClusterTemplateReturnsOnCall map[int]struct {
		result1 templates.Template
		result2 error
	}
	GetPipelineStub        func(string, string) (*v1alpha1.Pipeline, error)
	getPipelineMutex       sync.RWMutex
	getPipelineArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getPipelineReturns struct {
		result1 *v1alpha1.Pipeline
		result2 error
	}
	getPipelineReturnsOnCall map[int]struct {
		result1 *v1alpha1.Pipeline
		result2 error
	}
	GetRunTemplateStub        func(v1alpha1.TemplateReference) (templates.ClusterRunTemplate, error)
	getRunTemplateMutex       sync.RWMutex
	getRunTemplateArgsForCall []struct {
		arg1 v1alpha1.TemplateReference
	}
	getRunTemplateReturns struct {
		result1 templates.ClusterRunTemplate
		result2 error
	}
	getRunTemplateReturnsOnCall map[int]struct {
		result1 templates.ClusterRunTemplate
		result2 error
	}
	GetSchemeStub        func() *runtime.Scheme
	getSchemeMutex       sync.RWMutex
	getSchemeArgsForCall []struct {
	}
	getSchemeReturns struct {
		result1 *runtime.Scheme
	}
	getSchemeReturnsOnCall map[int]struct {
		result1 *runtime.Scheme
	}
	GetSupplyChainStub        func(string) (*v1alpha1.ClusterSupplyChain, error)
	getSupplyChainMutex       sync.RWMutex
	getSupplyChainArgsForCall []struct {
		arg1 string
	}
	getSupplyChainReturns struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetSupplyChainsForWorkloadStub        func(*v1alpha1.Workload) ([]v1alpha1.ClusterSupplyChain, error)
	getSupplyChainsForWorkloadMutex       sync.RWMutex
	getSupplyChainsForWorkloadArgsForCall []struct {
		arg1 *v1alpha1.Workload
	}
	getSupplyChainsForWorkloadReturns struct {
		result1 []v1alpha1.ClusterSupplyChain
		result2 error
	}
	getSupplyChainsForWorkloadReturnsOnCall map[int]struct {
		result1 []v1alpha1.ClusterSupplyChain
		result2 error
	}
	GetWorkloadStub        func(string, string) (*v1alpha1.Workload, error)
	getWorkloadMutex       sync.RWMutex
	getWorkloadArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getWorkloadReturns struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	getWorkloadReturnsOnCall map[int]struct {
		result1 *v1alpha1.Workload
		result2 error
	}
	ListUnstructuredStub        func(*unstructured.Unstructured) ([]*unstructured.Unstructured, error)
	listUnstructuredMutex       sync.RWMutex
	listUnstructuredArgsForCall []struct {
		arg1 *unstructured.Unstructured
	}
	listUnstructuredReturns struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	listUnstructuredReturnsOnCall map[int]struct {
		result1 []*unstructured.Unstructured
		result2 error
	}
	StatusUpdateStub        func(client.Object) error
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 client.Object
	}
	statusUpdateReturns struct {
		result1 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepository) EnsureObjectExistsOnCluster(arg1 *unstructured.Unstructured, arg2 bool) error {
	fake.ensureObjectExistsOnClusterMutex.Lock()
	ret, specificReturn := fake.ensureObjectExistsOnClusterReturnsOnCall[len(fake.ensureObjectExistsOnClusterArgsForCall)]
	fake.ensureObjectExistsOnClusterArgsForCall = append(fake.ensureObjectExistsOnClusterArgsForCall, struct {
		arg1 *unstructured.Unstructured
		arg2 bool
	}{arg1, arg2})
	stub := fake.EnsureObjectExistsOnClusterStub
	fakeReturns := fake.ensureObjectExistsOnClusterReturns
	fake.recordInvocation("EnsureObjectExistsOnCluster", []interface{}{arg1, arg2})
	fake.ensureObjectExistsOnClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) EnsureObjectExistsOnClusterCallCount() int {
	fake.ensureObjectExistsOnClusterMutex.RLock()
	defer fake.ensureObjectExistsOnClusterMutex.RUnlock()
	return len(fake.ensureObjectExistsOnClusterArgsForCall)
}

func (fake *FakeRepository) EnsureObjectExistsOnClusterCalls(stub func(*unstructured.Unstructured, bool) error) {
	fake.ensureObjectExistsOnClusterMutex.Lock()
	defer fake.ensureObjectExistsOnClusterMutex.Unlock()
	fake.EnsureObjectExistsOnClusterStub = stub
}

func (fake *FakeRepository) EnsureObjectExistsOnClusterArgsForCall(i int) (*unstructured.Unstructured, bool) {
	fake.ensureObjectExistsOnClusterMutex.RLock()
	defer fake.ensureObjectExistsOnClusterMutex.RUnlock()
	argsForCall := fake.ensureObjectExistsOnClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) EnsureObjectExistsOnClusterReturns(result1 error) {
	fake.ensureObjectExistsOnClusterMutex.Lock()
	defer fake.ensureObjectExistsOnClusterMutex.Unlock()
	fake.EnsureObjectExistsOnClusterStub = nil
	fake.ensureObjectExistsOnClusterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) EnsureObjectExistsOnClusterReturnsOnCall(i int, result1 error) {
	fake.ensureObjectExistsOnClusterMutex.Lock()
	defer fake.ensureObjectExistsOnClusterMutex.Unlock()
	fake.EnsureObjectExistsOnClusterStub = nil
	if fake.ensureObjectExistsOnClusterReturnsOnCall == nil {
		fake.ensureObjectExistsOnClusterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureObjectExistsOnClusterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetClusterTemplate(arg1 v1alpha1.ClusterTemplateReference) (templates.Template, error) {
	fake.getClusterTemplateMutex.Lock()
	ret, specificReturn := fake.getClusterTemplateReturnsOnCall[len(fake.getClusterTemplateArgsForCall)]
	fake.getClusterTemplateArgsForCall = append(fake.getClusterTemplateArgsForCall, struct {
		arg1 v1alpha1.ClusterTemplateReference
	}{arg1})
	stub := fake.GetClusterTemplateStub
	fakeReturns := fake.getClusterTemplateReturns
	fake.recordInvocation("GetClusterTemplate", []interface{}{arg1})
	fake.getClusterTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetClusterTemplateCallCount() int {
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	return len(fake.getClusterTemplateArgsForCall)
}

func (fake *FakeRepository) GetClusterTemplateCalls(stub func(v1alpha1.ClusterTemplateReference) (templates.Template, error)) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = stub
}

func (fake *FakeRepository) GetClusterTemplateArgsForCall(i int) v1alpha1.ClusterTemplateReference {
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	argsForCall := fake.getClusterTemplateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetClusterTemplateReturns(result1 templates.Template, result2 error) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = nil
	fake.getClusterTemplateReturns = struct {
		result1 templates.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetClusterTemplateReturnsOnCall(i int, result1 templates.Template, result2 error) {
	fake.getClusterTemplateMutex.Lock()
	defer fake.getClusterTemplateMutex.Unlock()
	fake.GetClusterTemplateStub = nil
	if fake.getClusterTemplateReturnsOnCall == nil {
		fake.getClusterTemplateReturnsOnCall = make(map[int]struct {
			result1 templates.Template
			result2 error
		})
	}
	fake.getClusterTemplateReturnsOnCall[i] = struct {
		result1 templates.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliverable(arg1 string, arg2 string) (*v1alpha1.Deliverable, error) {
	fake.getDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliverableReturnsOnCall[len(fake.getDeliverableArgsForCall)]
	fake.getDeliverableArgsForCall = append(fake.getDeliverableArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDeliverableStub
	fakeReturns := fake.getDeliverableReturns
	fake.recordInvocation("GetDeliverable", []interface{}{arg1, arg2})
	fake.getDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliverableCallCount() int {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	return len(fake.getDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliverableCalls(stub func(string, string) (*v1alpha1.Deliverable, error)) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliverableArgsForCall(i int) (string, string) {
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliverableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetDeliverableReturns(result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	fake.getDeliverableReturns = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliverableReturnsOnCall(i int, result1 *v1alpha1.Deliverable, result2 error) {
	fake.getDeliverableMutex.Lock()
	defer fake.getDeliverableMutex.Unlock()
	fake.GetDeliverableStub = nil
	if fake.getDeliverableReturnsOnCall == nil {
		fake.getDeliverableReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Deliverable
			result2 error
		})
	}
	fake.getDeliverableReturnsOnCall[i] = struct {
		result1 *v1alpha1.Deliverable
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverable(arg1 *v1alpha1.Deliverable) ([]v1alpha1.ClusterDelivery, error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	ret, specificReturn := fake.getDeliveriesForDeliverableReturnsOnCall[len(fake.getDeliveriesForDeliverableArgsForCall)]
	fake.getDeliveriesForDeliverableArgsForCall = append(fake.getDeliveriesForDeliverableArgsForCall, struct {
		arg1 *v1alpha1.Deliverable
	}{arg1})
	stub := fake.GetDeliveriesForDeliverableStub
	fakeReturns := fake.getDeliveriesForDeliverableReturns
	fake.recordInvocation("GetDeliveriesForDeliverable", []interface{}{arg1})
	fake.getDeliveriesForDeliverableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCallCount() int {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	return len(fake.getDeliveriesForDeliverableArgsForCall)
}

func (fake *FakeRepository) GetDeliveriesForDeliverableCalls(stub func(*v1alpha1.Deliverable) ([]v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = stub
}

func (fake *FakeRepository) GetDeliveriesForDeliverableArgsForCall(i int) *v1alpha1.Deliverable {
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	argsForCall := fake.getDeliveriesForDeliverableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturns(result1 []v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	fake.getDeliveriesForDeliverableReturns = struct {
		result1 []v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveriesForDeliverableReturnsOnCall(i int, result1 []v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveriesForDeliverableMutex.Lock()
	defer fake.getDeliveriesForDeliverableMutex.Unlock()
	fake.GetDeliveriesForDeliverableStub = nil
	if fake.getDeliveriesForDeliverableReturnsOnCall == nil {
		fake.getDeliveriesForDeliverableReturnsOnCall = make(map[int]struct {
			result1 []v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveriesForDeliverableReturnsOnCall[i] = struct {
		result1 []v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDelivery(arg1 string) (*v1alpha1.ClusterDelivery, error) {
	fake.getDeliveryMutex.Lock()
	ret, specificReturn := fake.getDeliveryReturnsOnCall[len(fake.getDeliveryArgsForCall)]
	fake.getDeliveryArgsForCall = append(fake.getDeliveryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetDeliveryStub
	fakeReturns := fake.getDeliveryReturns
	fake.recordInvocation("GetDelivery", []interface{}{arg1})
	fake.getDeliveryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveryCallCount() int {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	return len(fake.getDeliveryArgsForCall)
}

func (fake *FakeRepository) GetDeliveryCalls(stub func(string) (*v1alpha1.ClusterDelivery, error)) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = stub
}

func (fake *FakeRepository) GetDeliveryArgsForCall(i int) string {
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	argsForCall := fake.getDeliveryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetDeliveryReturns(result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	fake.getDeliveryReturns = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryReturnsOnCall(i int, result1 *v1alpha1.ClusterDelivery, result2 error) {
	fake.getDeliveryMutex.Lock()
	defer fake.getDeliveryMutex.Unlock()
	fake.GetDeliveryStub = nil
	if fake.getDeliveryReturnsOnCall == nil {
		fake.getDeliveryReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterDelivery
			result2 error
		})
	}
	fake.getDeliveryReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterDelivery
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryClusterTemplate(arg1 v1alpha1.DeliveryClusterTemplateReference) (templates.Template, error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	ret, specificReturn := fake.getDeliveryClusterTemplateReturnsOnCall[len(fake.getDeliveryClusterTemplateArgsForCall)]
	fake.getDeliveryClusterTemplateArgsForCall = append(fake.getDeliveryClusterTemplateArgsForCall, struct {
		arg1 v1alpha1.DeliveryClusterTemplateReference
	}{arg1})
	stub := fake.GetDeliveryClusterTemplateStub
	fakeReturns := fake.getDeliveryClusterTemplateReturns
	fake.recordInvocation("GetDeliveryClusterTemplate", []interface{}{arg1})
	fake.getDeliveryClusterTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetDeliveryClusterTemplateCallCount() int {
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	return len(fake.getDeliveryClusterTemplateArgsForCall)
}

func (fake *FakeRepository) GetDeliveryClusterTemplateCalls(stub func(v1alpha1.DeliveryClusterTemplateReference) (templates.Template, error)) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = stub
}

func (fake *FakeRepository) GetDeliveryClusterTemplateArgsForCall(i int) v1alpha1.DeliveryClusterTemplateReference {
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	argsForCall := fake.getDeliveryClusterTemplateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetDeliveryClusterTemplateReturns(result1 templates.Template, result2 error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = nil
	fake.getDeliveryClusterTemplateReturns = struct {
		result1 templates.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetDeliveryClusterTemplateReturnsOnCall(i int, result1 templates.Template, result2 error) {
	fake.getDeliveryClusterTemplateMutex.Lock()
	defer fake.getDeliveryClusterTemplateMutex.Unlock()
	fake.GetDeliveryClusterTemplateStub = nil
	if fake.getDeliveryClusterTemplateReturnsOnCall == nil {
		fake.getDeliveryClusterTemplateReturnsOnCall = make(map[int]struct {
			result1 templates.Template
			result2 error
		})
	}
	fake.getDeliveryClusterTemplateReturnsOnCall[i] = struct {
		result1 templates.Template
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetPipeline(arg1 string, arg2 string) (*v1alpha1.Pipeline, error) {
	fake.getPipelineMutex.Lock()
	ret, specificReturn := fake.getPipelineReturnsOnCall[len(fake.getPipelineArgsForCall)]
	fake.getPipelineArgsForCall = append(fake.getPipelineArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetPipelineStub
	fakeReturns := fake.getPipelineReturns
	fake.recordInvocation("GetPipeline", []interface{}{arg1, arg2})
	fake.getPipelineMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetPipelineCallCount() int {
	fake.getPipelineMutex.RLock()
	defer fake.getPipelineMutex.RUnlock()
	return len(fake.getPipelineArgsForCall)
}

func (fake *FakeRepository) GetPipelineCalls(stub func(string, string) (*v1alpha1.Pipeline, error)) {
	fake.getPipelineMutex.Lock()
	defer fake.getPipelineMutex.Unlock()
	fake.GetPipelineStub = stub
}

func (fake *FakeRepository) GetPipelineArgsForCall(i int) (string, string) {
	fake.getPipelineMutex.RLock()
	defer fake.getPipelineMutex.RUnlock()
	argsForCall := fake.getPipelineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetPipelineReturns(result1 *v1alpha1.Pipeline, result2 error) {
	fake.getPipelineMutex.Lock()
	defer fake.getPipelineMutex.Unlock()
	fake.GetPipelineStub = nil
	fake.getPipelineReturns = struct {
		result1 *v1alpha1.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetPipelineReturnsOnCall(i int, result1 *v1alpha1.Pipeline, result2 error) {
	fake.getPipelineMutex.Lock()
	defer fake.getPipelineMutex.Unlock()
	fake.GetPipelineStub = nil
	if fake.getPipelineReturnsOnCall == nil {
		fake.getPipelineReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Pipeline
			result2 error
		})
	}
	fake.getPipelineReturnsOnCall[i] = struct {
		result1 *v1alpha1.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunTemplate(arg1 v1alpha1.TemplateReference) (templates.ClusterRunTemplate, error) {
	fake.getRunTemplateMutex.Lock()
	ret, specificReturn := fake.getRunTemplateReturnsOnCall[len(fake.getRunTemplateArgsForCall)]
	fake.getRunTemplateArgsForCall = append(fake.getRunTemplateArgsForCall, struct {
		arg1 v1alpha1.TemplateReference
	}{arg1})
	stub := fake.GetRunTemplateStub
	fakeReturns := fake.getRunTemplateReturns
	fake.recordInvocation("GetRunTemplate", []interface{}{arg1})
	fake.getRunTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetRunTemplateCallCount() int {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	return len(fake.getRunTemplateArgsForCall)
}

func (fake *FakeRepository) GetRunTemplateCalls(stub func(v1alpha1.TemplateReference) (templates.ClusterRunTemplate, error)) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = stub
}

func (fake *FakeRepository) GetRunTemplateArgsForCall(i int) v1alpha1.TemplateReference {
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	argsForCall := fake.getRunTemplateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetRunTemplateReturns(result1 templates.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	fake.getRunTemplateReturns = struct {
		result1 templates.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRunTemplateReturnsOnCall(i int, result1 templates.ClusterRunTemplate, result2 error) {
	fake.getRunTemplateMutex.Lock()
	defer fake.getRunTemplateMutex.Unlock()
	fake.GetRunTemplateStub = nil
	if fake.getRunTemplateReturnsOnCall == nil {
		fake.getRunTemplateReturnsOnCall = make(map[int]struct {
			result1 templates.ClusterRunTemplate
			result2 error
		})
	}
	fake.getRunTemplateReturnsOnCall[i] = struct {
		result1 templates.ClusterRunTemplate
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetScheme() *runtime.Scheme {
	fake.getSchemeMutex.Lock()
	ret, specificReturn := fake.getSchemeReturnsOnCall[len(fake.getSchemeArgsForCall)]
	fake.getSchemeArgsForCall = append(fake.getSchemeArgsForCall, struct {
	}{})
	stub := fake.GetSchemeStub
	fakeReturns := fake.getSchemeReturns
	fake.recordInvocation("GetScheme", []interface{}{})
	fake.getSchemeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) GetSchemeCallCount() int {
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	return len(fake.getSchemeArgsForCall)
}

func (fake *FakeRepository) GetSchemeCalls(stub func() *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = stub
}

func (fake *FakeRepository) GetSchemeReturns(result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	fake.getSchemeReturns = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetSchemeReturnsOnCall(i int, result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	if fake.getSchemeReturnsOnCall == nil {
		fake.getSchemeReturnsOnCall = make(map[int]struct {
			result1 *runtime.Scheme
		})
	}
	fake.getSchemeReturnsOnCall[i] = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeRepository) GetSupplyChain(arg1 string) (*v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainMutex.Lock()
	ret, specificReturn := fake.getSupplyChainReturnsOnCall[len(fake.getSupplyChainArgsForCall)]
	fake.getSupplyChainArgsForCall = append(fake.getSupplyChainArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSupplyChainStub
	fakeReturns := fake.getSupplyChainReturns
	fake.recordInvocation("GetSupplyChain", []interface{}{arg1})
	fake.getSupplyChainMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainCallCount() int {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	return len(fake.getSupplyChainArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainCalls(stub func(string) (*v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = stub
}

func (fake *FakeRepository) GetSupplyChainArgsForCall(i int) string {
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	argsForCall := fake.getSupplyChainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetSupplyChainReturns(result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	fake.getSupplyChainReturns = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainReturnsOnCall(i int, result1 *v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainMutex.Lock()
	defer fake.getSupplyChainMutex.Unlock()
	fake.GetSupplyChainStub = nil
	if fake.getSupplyChainReturnsOnCall == nil {
		fake.getSupplyChainReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkload(arg1 *v1alpha1.Workload) ([]v1alpha1.ClusterSupplyChain, error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	ret, specificReturn := fake.getSupplyChainsForWorkloadReturnsOnCall[len(fake.getSupplyChainsForWorkloadArgsForCall)]
	fake.getSupplyChainsForWorkloadArgsForCall = append(fake.getSupplyChainsForWorkloadArgsForCall, struct {
		arg1 *v1alpha1.Workload
	}{arg1})
	stub := fake.GetSupplyChainsForWorkloadStub
	fakeReturns := fake.getSupplyChainsForWorkloadReturns
	fake.recordInvocation("GetSupplyChainsForWorkload", []interface{}{arg1})
	fake.getSupplyChainsForWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCallCount() int {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	return len(fake.getSupplyChainsForWorkloadArgsForCall)
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadCalls(stub func(*v1alpha1.Workload) ([]v1alpha1.ClusterSupplyChain, error)) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = stub
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadArgsForCall(i int) *v1alpha1.Workload {
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	argsForCall := fake.getSupplyChainsForWorkloadArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturns(result1 []v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	fake.getSupplyChainsForWorkloadReturns = struct {
		result1 []v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetSupplyChainsForWorkloadReturnsOnCall(i int, result1 []v1alpha1.ClusterSupplyChain, result2 error) {
	fake.getSupplyChainsForWorkloadMutex.Lock()
	defer fake.getSupplyChainsForWorkloadMutex.Unlock()
	fake.GetSupplyChainsForWorkloadStub = nil
	if fake.getSupplyChainsForWorkloadReturnsOnCall == nil {
		fake.getSupplyChainsForWorkloadReturnsOnCall = make(map[int]struct {
			result1 []v1alpha1.ClusterSupplyChain
			result2 error
		})
	}
	fake.getSupplyChainsForWorkloadReturnsOnCall[i] = struct {
		result1 []v1alpha1.ClusterSupplyChain
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkload(arg1 string, arg2 string) (*v1alpha1.Workload, error) {
	fake.getWorkloadMutex.Lock()
	ret, specificReturn := fake.getWorkloadReturnsOnCall[len(fake.getWorkloadArgsForCall)]
	fake.getWorkloadArgsForCall = append(fake.getWorkloadArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetWorkloadStub
	fakeReturns := fake.getWorkloadReturns
	fake.recordInvocation("GetWorkload", []interface{}{arg1, arg2})
	fake.getWorkloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) GetWorkloadCallCount() int {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	return len(fake.getWorkloadArgsForCall)
}

func (fake *FakeRepository) GetWorkloadCalls(stub func(string, string) (*v1alpha1.Workload, error)) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = stub
}

func (fake *FakeRepository) GetWorkloadArgsForCall(i int) (string, string) {
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	argsForCall := fake.getWorkloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRepository) GetWorkloadReturns(result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	fake.getWorkloadReturns = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetWorkloadReturnsOnCall(i int, result1 *v1alpha1.Workload, result2 error) {
	fake.getWorkloadMutex.Lock()
	defer fake.getWorkloadMutex.Unlock()
	fake.GetWorkloadStub = nil
	if fake.getWorkloadReturnsOnCall == nil {
		fake.getWorkloadReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Workload
			result2 error
		})
	}
	fake.getWorkloadReturnsOnCall[i] = struct {
		result1 *v1alpha1.Workload
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructured(arg1 *unstructured.Unstructured) ([]*unstructured.Unstructured, error) {
	fake.listUnstructuredMutex.Lock()
	ret, specificReturn := fake.listUnstructuredReturnsOnCall[len(fake.listUnstructuredArgsForCall)]
	fake.listUnstructuredArgsForCall = append(fake.listUnstructuredArgsForCall, struct {
		arg1 *unstructured.Unstructured
	}{arg1})
	stub := fake.ListUnstructuredStub
	fakeReturns := fake.listUnstructuredReturns
	fake.recordInvocation("ListUnstructured", []interface{}{arg1})
	fake.listUnstructuredMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRepository) ListUnstructuredCallCount() int {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	return len(fake.listUnstructuredArgsForCall)
}

func (fake *FakeRepository) ListUnstructuredCalls(stub func(*unstructured.Unstructured) ([]*unstructured.Unstructured, error)) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = stub
}

func (fake *FakeRepository) ListUnstructuredArgsForCall(i int) *unstructured.Unstructured {
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	argsForCall := fake.listUnstructuredArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) ListUnstructuredReturns(result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	fake.listUnstructuredReturns = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) ListUnstructuredReturnsOnCall(i int, result1 []*unstructured.Unstructured, result2 error) {
	fake.listUnstructuredMutex.Lock()
	defer fake.listUnstructuredMutex.Unlock()
	fake.ListUnstructuredStub = nil
	if fake.listUnstructuredReturnsOnCall == nil {
		fake.listUnstructuredReturnsOnCall = make(map[int]struct {
			result1 []*unstructured.Unstructured
			result2 error
		})
	}
	fake.listUnstructuredReturnsOnCall[i] = struct {
		result1 []*unstructured.Unstructured
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) StatusUpdate(arg1 client.Object) error {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 client.Object
	}{arg1})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepository) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakeRepository) StatusUpdateCalls(stub func(client.Object) error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakeRepository) StatusUpdateArgsForCall(i int) client.Object {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRepository) StatusUpdateReturns(result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) StatusUpdateReturnsOnCall(i int, result1 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.ensureObjectExistsOnClusterMutex.RLock()
	defer fake.ensureObjectExistsOnClusterMutex.RUnlock()
	fake.getClusterTemplateMutex.RLock()
	defer fake.getClusterTemplateMutex.RUnlock()
	fake.getDeliverableMutex.RLock()
	defer fake.getDeliverableMutex.RUnlock()
	fake.getDeliveriesForDeliverableMutex.RLock()
	defer fake.getDeliveriesForDeliverableMutex.RUnlock()
	fake.getDeliveryMutex.RLock()
	defer fake.getDeliveryMutex.RUnlock()
	fake.getDeliveryClusterTemplateMutex.RLock()
	defer fake.getDeliveryClusterTemplateMutex.RUnlock()
	fake.getPipelineMutex.RLock()
	defer fake.getPipelineMutex.RUnlock()
	fake.getRunTemplateMutex.RLock()
	defer fake.getRunTemplateMutex.RUnlock()
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	fake.getSupplyChainMutex.RLock()
	defer fake.getSupplyChainMutex.RUnlock()
	fake.getSupplyChainsForWorkloadMutex.RLock()
	defer fake.getSupplyChainsForWorkloadMutex.RUnlock()
	fake.getWorkloadMutex.RLock()
	defer fake.getWorkloadMutex.RUnlock()
	fake.listUnstructuredMutex.RLock()
	defer fake.listUnstructuredMutex.RUnlock()
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.Repository = new(FakeRepository)

// Code generated by counterfeiter. DO NOT EDIT.
package satokenfakes

import (
	"sync"

	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
	"k8s.io/client-go/rest"
)

type FakeCoreV1Interface struct {
	ComponentStatusesStub        func() v1.ComponentStatusInterface
	componentStatusesMutex       sync.RWMutex
	componentStatusesArgsForCall []struct {
	}
	componentStatusesReturns struct {
		result1 v1.ComponentStatusInterface
	}
	componentStatusesReturnsOnCall map[int]struct {
		result1 v1.ComponentStatusInterface
	}
	ConfigMapsStub        func(string) v1.ConfigMapInterface
	configMapsMutex       sync.RWMutex
	configMapsArgsForCall []struct {
		arg1 string
	}
	configMapsReturns struct {
		result1 v1.ConfigMapInterface
	}
	configMapsReturnsOnCall map[int]struct {
		result1 v1.ConfigMapInterface
	}
	EndpointsStub        func(string) v1.EndpointsInterface
	endpointsMutex       sync.RWMutex
	endpointsArgsForCall []struct {
		arg1 string
	}
	endpointsReturns struct {
		result1 v1.EndpointsInterface
	}
	endpointsReturnsOnCall map[int]struct {
		result1 v1.EndpointsInterface
	}
	EventsStub        func(string) v1.EventInterface
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 string
	}
	eventsReturns struct {
		result1 v1.EventInterface
	}
	eventsReturnsOnCall map[int]struct {
		result1 v1.EventInterface
	}
	LimitRangesStub        func(string) v1.LimitRangeInterface
	limitRangesMutex       sync.RWMutex
	limitRangesArgsForCall []struct {
		arg1 string
	}
	limitRangesReturns struct {
		result1 v1.LimitRangeInterface
	}
	limitRangesReturnsOnCall map[int]struct {
		result1 v1.LimitRangeInterface
	}
	NamespacesStub        func() v1.NamespaceInterface
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
	}
	namespacesReturns struct {
		result1 v1.NamespaceInterface
	}
	namespacesReturnsOnCall map[int]struct {
		result1 v1.NamespaceInterface
	}
	NodesStub        func() v1.NodeInterface
	nodesMutex       sync.RWMutex
	nodesArgsForCall []struct {
	}
	nodesReturns struct {
		result1 v1.NodeInterface
	}
	nodesReturnsOnCall map[int]struct {
		result1 v1.NodeInterface
	}
	PersistentVolumeClaimsStub        func(string) v1.PersistentVolumeClaimInterface
	persistentVolumeClaimsMutex       sync.RWMutex
	persistentVolumeClaimsArgsForCall []struct {
		arg1 string
	}
	persistentVolumeClaimsReturns struct {
		result1 v1.PersistentVolumeClaimInterface
	}
	persistentVolumeClaimsReturnsOnCall map[int]struct {
		result1 v1.PersistentVolumeClaimInterface
	}
	PersistentVolumesStub        func() v1.PersistentVolumeInterface
	persistentVolumesMutex       sync.RWMutex
	persistentVolumesArgsForCall []struct {
	}
	persistentVolumesReturns struct {
		result1 v1.PersistentVolumeInterface
	}
	persistentVolumesReturnsOnCall map[int]struct {
		result1 v1.PersistentVolumeInterface
	}
	PodTemplatesStub        func(string) v1.PodTemplateInterface
	podTemplatesMutex       sync.RWMutex
	podTemplatesArgsForCall []struct {
		arg1 string
	}
	podTemplatesReturns struct {
		result1 v1.PodTemplateInterface
	}
	podTemplatesReturnsOnCall map[int]struct {
		result1 v1.PodTemplateInterface
	}
	PodsStub        func(string) v1.PodInterface
	podsMutex       sync.RWMutex
	podsArgsForCall []struct {
		arg1 string
	}
	podsReturns struct {
		result1 v1.PodInterface
	}
	podsReturnsOnCall map[int]struct {
		result1 v1.PodInterface
	}
	RESTClientStub        func() rest.Interface
	rESTClientMutex       sync.RWMutex
	rESTClientArgsForCall []struct {
	}
	rESTClientReturns struct {
		result1 rest.Interface
	}
	rESTClientReturnsOnCall map[int]struct {
		result1 rest.Interface
	}
	ReplicationControllersStub        func(string) v1.ReplicationControllerInterface
	replicationControllersMutex       sync.RWMutex
	replicationControllersArgsForCall []struct {
		arg1 string
	}
	replicationControllersReturns struct {
		result1 v1.ReplicationControllerInterface
	}
	replicationControllersReturnsOnCall map[int]struct {
		result1 v1.ReplicationControllerInterface
	}
	ResourceQuotasStub        func(string) v1.ResourceQuotaInterface
	resourceQuotasMutex       sync.RWMutex
	resourceQuotasArgsForCall []struct {
		arg1 string
	}
	resourceQuotasReturns struct {
		result1 v1.ResourceQuotaInterface
	}
	resourceQuotasReturnsOnCall map[int]struct {
		result1 v1.ResourceQuotaInterface
	}
	SecretsStub        func(string) v1.SecretInterface
	secretsMutex       sync.RWMutex
	secretsArgsForCall []struct {
		arg1 string
	}
	secretsReturns struct {
		result1 v1.SecretInterface
	}
	secretsReturnsOnCall map[int]struct {
		result1 v1.SecretInterface
	}
	ServiceAccountsStub        func(string) v1.ServiceAccountInterface
	serviceAccountsMutex       sync.RWMutex
	serviceAccountsArgsForCall []struct {
		arg1 string
	}
	serviceAccountsReturns struct {
		result1 v1.ServiceAccountInterface
	}
	serviceAccountsReturnsOnCall map[int]struct {
		result1 v1.ServiceAccountInterface
	}
	ServicesStub        func(string) v1.ServiceInterface
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct {
		arg1 string
	}
	servicesReturns struct {
		result1 v1.ServiceInterface
	}
	servicesReturnsOnCall map[int]struct {
		result1 v1.ServiceInterface
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCoreV1Interface) ComponentStatuses() v1.ComponentStatusInterface {
	fake.componentStatusesMutex.Lock()
	ret, specificReturn := fake.componentStatusesReturnsOnCall[len(fake.componentStatusesArgsForCall)]
	fake.componentStatusesArgsForCall = append(fake.componentStatusesArgsForCall, struct {
	}{})
	stub := fake.ComponentStatusesStub
	fakeReturns := fake.componentStatusesReturns
	fake.recordInvocation("ComponentStatuses", []interface{}{})
	fake.componentStatusesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ComponentStatusesCallCount() int {
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	return len(fake.componentStatusesArgsForCall)
}

func (fake *FakeCoreV1Interface) ComponentStatusesCalls(stub func() v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = stub
}

func (fake *FakeCoreV1Interface) ComponentStatusesReturns(result1 v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = nil
	fake.componentStatusesReturns = struct {
		result1 v1.ComponentStatusInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ComponentStatusesReturnsOnCall(i int, result1 v1.ComponentStatusInterface) {
	fake.componentStatusesMutex.Lock()
	defer fake.componentStatusesMutex.Unlock()
	fake.ComponentStatusesStub = nil
	if fake.componentStatusesReturnsOnCall == nil {
		fake.componentStatusesReturnsOnCall = make(map[int]struct {
			result1 v1.ComponentStatusInterface
		})
	}
	fake.componentStatusesReturnsOnCall[i] = struct {
		result1 v1.ComponentStatusInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ConfigMaps(arg1 string) v1.ConfigMapInterface {
	fake.configMapsMutex.Lock()
	ret, specificReturn := fake.configMapsReturnsOnCall[len(fake.configMapsArgsForCall)]
	fake.configMapsArgsForCall = append(fake.configMapsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ConfigMapsStub
	fakeReturns := fake.configMapsReturns
	fake.recordInvocation("ConfigMaps", []interface{}{arg1})
	fake.configMapsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ConfigMapsCallCount() int {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	return len(fake.configMapsArgsForCall)
}

func (fake *FakeCoreV1Interface) ConfigMapsCalls(stub func(string) v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = stub
}

func (fake *FakeCoreV1Interface) ConfigMapsArgsForCall(i int) string {
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	argsForCall := fake.configMapsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) ConfigMapsReturns(result1 v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = nil
	fake.configMapsReturns = struct {
		result1 v1.ConfigMapInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ConfigMapsReturnsOnCall(i int, result1 v1.ConfigMapInterface) {
	fake.configMapsMutex.Lock()
	defer fake.configMapsMutex.Unlock()
	fake.ConfigMapsStub = nil
	if fake.configMapsReturnsOnCall == nil {
		fake.configMapsReturnsOnCall = make(map[int]struct {
			result1 v1.ConfigMapInterface
		})
	}
	fake.configMapsReturnsOnCall[i] = struct {
		result1 v1.ConfigMapInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Endpoints(arg1 string) v1.EndpointsInterface {
	fake.endpointsMutex.Lock()
	ret, specificReturn := fake.endpointsReturnsOnCall[len(fake.endpointsArgsForCall)]
	fake.endpointsArgsForCall = append(fake.endpointsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EndpointsStub
	fakeReturns := fake.endpointsReturns
	fake.recordInvocation("Endpoints", []interface{}{arg1})
	fake.endpointsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) EndpointsCallCount() int {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	return len(fake.endpointsArgsForCall)
}

func (fake *FakeCoreV1Interface) EndpointsCalls(stub func(string) v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = stub
}

func (fake *FakeCoreV1Interface) EndpointsArgsForCall(i int) string {
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	argsForCall := fake.endpointsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) EndpointsReturns(result1 v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = nil
	fake.endpointsReturns = struct {
		result1 v1.EndpointsInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) EndpointsReturnsOnCall(i int, result1 v1.EndpointsInterface) {
	fake.endpointsMutex.Lock()
	defer fake.endpointsMutex.Unlock()
	fake.EndpointsStub = nil
	if fake.endpointsReturnsOnCall == nil {
		fake.endpointsReturnsOnCall = make(map[int]struct {
			result1 v1.EndpointsInterface
		})
	}
	fake.endpointsReturnsOnCall[i] = struct {
		result1 v1.EndpointsInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Events(arg1 string) v1.EventInterface {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EventsStub
	fakeReturns := fake.eventsReturns
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeCoreV1Interface) EventsCalls(stub func(string) v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeCoreV1Interface) EventsArgsForCall(i int) string {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) EventsReturns(result1 v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 v1.EventInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) EventsReturnsOnCall(i int, result1 v1.EventInterface) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 v1.EventInterface
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 v1.EventInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) LimitRanges(arg1 string) v1.LimitRangeInterface {
	fake.limitRangesMutex.Lock()
	ret, specificReturn := fake.limitRangesReturnsOnCall[len(fake.limitRangesArgsForCall)]
	fake.limitRangesArgsForCall = append(fake.limitRangesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LimitRangesStub
	fakeReturns := fake.limitRangesReturns
	fake.recordInvocation("LimitRanges", []interface{}{arg1})
	fake.limitRangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) LimitRangesCallCount() int {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	return len(fake.limitRangesArgsForCall)
}

func (fake *FakeCoreV1Interface) LimitRangesCalls(stub func(string) v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = stub
}

func (fake *FakeCoreV1Interface) LimitRangesArgsForCall(i int) string {
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	argsForCall := fake.limitRangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) LimitRangesReturns(result1 v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = nil
	fake.limitRangesReturns = struct {
		result1 v1.LimitRangeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) LimitRangesReturnsOnCall(i int, result1 v1.LimitRangeInterface) {
	fake.limitRangesMutex.Lock()
	defer fake.limitRangesMutex.Unlock()
	fake.LimitRangesStub = nil
	if fake.limitRangesReturnsOnCall == nil {
		fake.limitRangesReturnsOnCall = make(map[int]struct {
			result1 v1.LimitRangeInterface
		})
	}
	fake.limitRangesReturnsOnCall[i] = struct {
		result1 v1.LimitRangeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Namespaces() v1.NamespaceInterface {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
	}{})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeCoreV1Interface) NamespacesCalls(stub func() v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeCoreV1Interface) NamespacesReturns(result1 v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 v1.NamespaceInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) NamespacesReturnsOnCall(i int, result1 v1.NamespaceInterface) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 v1.NamespaceInterface
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 v1.NamespaceInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Nodes() v1.NodeInterface {
	fake.nodesMutex.Lock()
	ret, specificReturn := fake.nodesReturnsOnCall[len(fake.nodesArgsForCall)]
	fake.nodesArgsForCall = append(fake.nodesArgsForCall, struct {
	}{})
	stub := fake.NodesStub
	fakeReturns := fake.nodesReturns
	fake.recordInvocation("Nodes", []interface{}{})
	fake.nodesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) NodesCallCount() int {
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	return len(fake.nodesArgsForCall)
}

func (fake *FakeCoreV1Interface) NodesCalls(stub func() v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = stub
}

func (fake *FakeCoreV1Interface) NodesReturns(result1 v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = nil
	fake.nodesReturns = struct {
		result1 v1.NodeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) NodesReturnsOnCall(i int, result1 v1.NodeInterface) {
	fake.nodesMutex.Lock()
	defer fake.nodesMutex.Unlock()
	fake.NodesStub = nil
	if fake.nodesReturnsOnCall == nil {
		fake.nodesReturnsOnCall = make(map[int]struct {
			result1 v1.NodeInterface
		})
	}
	fake.nodesReturnsOnCall[i] = struct {
		result1 v1.NodeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaims(arg1 string) v1.PersistentVolumeClaimInterface {
	fake.persistentVolumeClaimsMutex.Lock()
	ret, specificReturn := fake.persistentVolumeClaimsReturnsOnCall[len(fake.persistentVolumeClaimsArgsForCall)]
	fake.persistentVolumeClaimsArgsForCall = append(fake.persistentVolumeClaimsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PersistentVolumeClaimsStub
	fakeReturns := fake.persistentVolumeClaimsReturns
	fake.recordInvocation("PersistentVolumeClaims", []interface{}{arg1})
	fake.persistentVolumeClaimsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaimsCallCount() int {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	return len(fake.persistentVolumeClaimsArgsForCall)
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaimsCalls(stub func(string) v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = stub
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaimsArgsForCall(i int) string {
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	argsForCall := fake.persistentVolumeClaimsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaimsReturns(result1 v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = nil
	fake.persistentVolumeClaimsReturns = struct {
		result1 v1.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PersistentVolumeClaimsReturnsOnCall(i int, result1 v1.PersistentVolumeClaimInterface) {
	fake.persistentVolumeClaimsMutex.Lock()
	defer fake.persistentVolumeClaimsMutex.Unlock()
	fake.PersistentVolumeClaimsStub = nil
	if fake.persistentVolumeClaimsReturnsOnCall == nil {
		fake.persistentVolumeClaimsReturnsOnCall = make(map[int]struct {
			result1 v1.PersistentVolumeClaimInterface
		})
	}
	fake.persistentVolumeClaimsReturnsOnCall[i] = struct {
		result1 v1.PersistentVolumeClaimInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PersistentVolumes() v1.PersistentVolumeInterface {
	fake.persistentVolumesMutex.Lock()
	ret, specificReturn := fake.persistentVolumesReturnsOnCall[len(fake.persistentVolumesArgsForCall)]
	fake.persistentVolumesArgsForCall = append(fake.persistentVolumesArgsForCall, struct {
	}{})
	stub := fake.PersistentVolumesStub
	fakeReturns := fake.persistentVolumesReturns
	fake.recordInvocation("PersistentVolumes", []interface{}{})
	fake.persistentVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) PersistentVolumesCallCount() int {
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	return len(fake.persistentVolumesArgsForCall)
}

func (fake *FakeCoreV1Interface) PersistentVolumesCalls(stub func() v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = stub
}

func (fake *FakeCoreV1Interface) PersistentVolumesReturns(result1 v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = nil
	fake.persistentVolumesReturns = struct {
		result1 v1.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PersistentVolumesReturnsOnCall(i int, result1 v1.PersistentVolumeInterface) {
	fake.persistentVolumesMutex.Lock()
	defer fake.persistentVolumesMutex.Unlock()
	fake.PersistentVolumesStub = nil
	if fake.persistentVolumesReturnsOnCall == nil {
		fake.persistentVolumesReturnsOnCall = make(map[int]struct {
			result1 v1.PersistentVolumeInterface
		})
	}
	fake.persistentVolumesReturnsOnCall[i] = struct {
		result1 v1.PersistentVolumeInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PodTemplates(arg1 string) v1.PodTemplateInterface {
	fake.podTemplatesMutex.Lock()
	ret, specificReturn := fake.podTemplatesReturnsOnCall[len(fake.podTemplatesArgsForCall)]
	fake.podTemplatesArgsForCall = append(fake.podTemplatesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PodTemplatesStub
	fakeReturns := fake.podTemplatesReturns
	fake.recordInvocation("PodTemplates", []interface{}{arg1})
	fake.podTemplatesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) PodTemplatesCallCount() int {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	return len(fake.podTemplatesArgsForCall)
}

func (fake *FakeCoreV1Interface) PodTemplatesCalls(stub func(string) v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = stub
}

func (fake *FakeCoreV1Interface) PodTemplatesArgsForCall(i int) string {
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	argsForCall := fake.podTemplatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) PodTemplatesReturns(result1 v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = nil
	fake.podTemplatesReturns = struct {
		result1 v1.PodTemplateInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PodTemplatesReturnsOnCall(i int, result1 v1.PodTemplateInterface) {
	fake.podTemplatesMutex.Lock()
	defer fake.podTemplatesMutex.Unlock()
	fake.PodTemplatesStub = nil
	if fake.podTemplatesReturnsOnCall == nil {
		fake.podTemplatesReturnsOnCall = make(map[int]struct {
			result1 v1.PodTemplateInterface
		})
	}
	fake.podTemplatesReturnsOnCall[i] = struct {
		result1 v1.PodTemplateInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Pods(arg1 string) v1.PodInterface {
	fake.podsMutex.Lock()
	ret, specificReturn := fake.podsReturnsOnCall[len(fake.podsArgsForCall)]
	fake.podsArgsForCall = append(fake.podsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PodsStub
	fakeReturns := fake.podsReturns
	fake.recordInvocation("Pods", []interface{}{arg1})
	fake.podsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) PodsCallCount() int {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	return len(fake.podsArgsForCall)
}

func (fake *FakeCoreV1Interface) PodsCalls(stub func(string) v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = stub
}

func (fake *FakeCoreV1Interface) PodsArgsForCall(i int) string {
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	argsForCall := fake.podsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) PodsReturns(result1 v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = nil
	fake.podsReturns = struct {
		result1 v1.PodInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) PodsReturnsOnCall(i int, result1 v1.PodInterface) {
	fake.podsMutex.Lock()
	defer fake.podsMutex.Unlock()
	fake.PodsStub = nil
	if fake.podsReturnsOnCall == nil {
		fake.podsReturnsOnCall = make(map[int]struct {
			result1 v1.PodInterface
		})
	}
	fake.podsReturnsOnCall[i] = struct {
		result1 v1.PodInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) RESTClient() rest.Interface {
	fake.rESTClientMutex.Lock()
	ret, specificReturn := fake.rESTClientReturnsOnCall[len(fake.rESTClientArgsForCall)]
	fake.rESTClientArgsForCall = append(fake.rESTClientArgsForCall, struct {
	}{})
	stub := fake.RESTClientStub
	fakeReturns := fake.rESTClientReturns
	fake.recordInvocation("RESTClient", []interface{}{})
	fake.rESTClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) RESTClientCallCount() int {
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	return len(fake.rESTClientArgsForCall)
}

func (fake *FakeCoreV1Interface) RESTClientCalls(stub func() rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = stub
}

func (fake *FakeCoreV1Interface) RESTClientReturns(result1 rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = nil
	fake.rESTClientReturns = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeCoreV1Interface) RESTClientReturnsOnCall(i int, result1 rest.Interface) {
	fake.rESTClientMutex.Lock()
	defer fake.rESTClientMutex.Unlock()
	fake.RESTClientStub = nil
	if fake.rESTClientReturnsOnCall == nil {
		fake.rESTClientReturnsOnCall = make(map[int]struct {
			result1 rest.Interface
		})
	}
	fake.rESTClientReturnsOnCall[i] = struct {
		result1 rest.Interface
	}{result1}
}

func (fake *FakeCoreV1Interface) ReplicationControllers(arg1 string) v1.ReplicationControllerInterface {
	fake.replicationControllersMutex.Lock()
	ret, specificReturn := fake.replicationControllersReturnsOnCall[len(fake.replicationControllersArgsForCall)]
	fake.replicationControllersArgsForCall = append(fake.replicationControllersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReplicationControllersStub
	fakeReturns := fake.replicationControllersReturns
	fake.recordInvocation("ReplicationControllers", []interface{}{arg1})
	fake.replicationControllersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ReplicationControllersCallCount() int {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	return len(fake.replicationControllersArgsForCall)
}

func (fake *FakeCoreV1Interface) ReplicationControllersCalls(stub func(string) v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = stub
}

func (fake *FakeCoreV1Interface) ReplicationControllersArgsForCall(i int) string {
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	argsForCall := fake.replicationControllersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) ReplicationControllersReturns(result1 v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = nil
	fake.replicationControllersReturns = struct {
		result1 v1.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ReplicationControllersReturnsOnCall(i int, result1 v1.ReplicationControllerInterface) {
	fake.replicationControllersMutex.Lock()
	defer fake.replicationControllersMutex.Unlock()
	fake.ReplicationControllersStub = nil
	if fake.replicationControllersReturnsOnCall == nil {
		fake.replicationControllersReturnsOnCall = make(map[int]struct {
			result1 v1.ReplicationControllerInterface
		})
	}
	fake.replicationControllersReturnsOnCall[i] = struct {
		result1 v1.ReplicationControllerInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ResourceQuotas(arg1 string) v1.ResourceQuotaInterface {
	fake.resourceQuotasMutex.Lock()
	ret, specificReturn := fake.resourceQuotasReturnsOnCall[len(fake.resourceQuotasArgsForCall)]
	fake.resourceQuotasArgsForCall = append(fake.resourceQuotasArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResourceQuotasStub
	fakeReturns := fake.resourceQuotasReturns
	fake.recordInvocation("ResourceQuotas", []interface{}{arg1})
	fake.resourceQuotasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ResourceQuotasCallCount() int {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	return len(fake.resourceQuotasArgsForCall)
}

func (fake *FakeCoreV1Interface) ResourceQuotasCalls(stub func(string) v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = stub
}

func (fake *FakeCoreV1Interface) ResourceQuotasArgsForCall(i int) string {
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	argsForCall := fake.resourceQuotasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) ResourceQuotasReturns(result1 v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = nil
	fake.resourceQuotasReturns = struct {
		result1 v1.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ResourceQuotasReturnsOnCall(i int, result1 v1.ResourceQuotaInterface) {
	fake.resourceQuotasMutex.Lock()
	defer fake.resourceQuotasMutex.Unlock()
	fake.ResourceQuotasStub = nil
	if fake.resourceQuotasReturnsOnCall == nil {
		fake.resourceQuotasReturnsOnCall = make(map[int]struct {
			result1 v1.ResourceQuotaInterface
		})
	}
	fake.resourceQuotasReturnsOnCall[i] = struct {
		result1 v1.ResourceQuotaInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Secrets(arg1 string) v1.SecretInterface {
	fake.secretsMutex.Lock()
	ret, specificReturn := fake.secretsReturnsOnCall[len(fake.secretsArgsForCall)]
	fake.secretsArgsForCall = append(fake.secretsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SecretsStub
	fakeReturns := fake.secretsReturns
	fake.recordInvocation("Secrets", []interface{}{arg1})
	fake.secretsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) SecretsCallCount() int {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	return len(fake.secretsArgsForCall)
}

func (fake *FakeCoreV1Interface) SecretsCalls(stub func(string) v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = stub
}

func (fake *FakeCoreV1Interface) SecretsArgsForCall(i int) string {
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	argsForCall := fake.secretsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) SecretsReturns(result1 v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = nil
	fake.secretsReturns = struct {
		result1 v1.SecretInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) SecretsReturnsOnCall(i int, result1 v1.SecretInterface) {
	fake.secretsMutex.Lock()
	defer fake.secretsMutex.Unlock()
	fake.SecretsStub = nil
	if fake.secretsReturnsOnCall == nil {
		fake.secretsReturnsOnCall = make(map[int]struct {
			result1 v1.SecretInterface
		})
	}
	fake.secretsReturnsOnCall[i] = struct {
		result1 v1.SecretInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ServiceAccounts(arg1 string) v1.ServiceAccountInterface {
	fake.serviceAccountsMutex.Lock()
	ret, specificReturn := fake.serviceAccountsReturnsOnCall[len(fake.serviceAccountsArgsForCall)]
	fake.serviceAccountsArgsForCall = append(fake.serviceAccountsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceAccountsStub
	fakeReturns := fake.serviceAccountsReturns
	fake.recordInvocation("ServiceAccounts", []interface{}{arg1})
	fake.serviceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ServiceAccountsCallCount() int {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	return len(fake.serviceAccountsArgsForCall)
}

func (fake *FakeCoreV1Interface) ServiceAccountsCalls(stub func(string) v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = stub
}

func (fake *FakeCoreV1Interface) ServiceAccountsArgsForCall(i int) string {
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	argsForCall := fake.serviceAccountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) ServiceAccountsReturns(result1 v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = nil
	fake.serviceAccountsReturns = struct {
		result1 v1.ServiceAccountInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ServiceAccountsReturnsOnCall(i int, result1 v1.ServiceAccountInterface) {
	fake.serviceAccountsMutex.Lock()
	defer fake.serviceAccountsMutex.Unlock()
	fake.ServiceAccountsStub = nil
	if fake.serviceAccountsReturnsOnCall == nil {
		fake.serviceAccountsReturnsOnCall = make(map[int]struct {
			result1 v1.ServiceAccountInterface
		})
	}
	fake.serviceAccountsReturnsOnCall[i] = struct {
		result1 v1.ServiceAccountInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Services(arg1 string) v1.ServiceInterface {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServicesStub
	fakeReturns := fake.servicesReturns
	fake.recordInvocation("Services", []interface{}{arg1})
	fake.servicesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCoreV1Interface) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *FakeCoreV1Interface) ServicesCalls(stub func(string) v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = stub
}

func (fake *FakeCoreV1Interface) ServicesArgsForCall(i int) string {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	argsForCall := fake.servicesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCoreV1Interface) ServicesReturns(result1 v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 v1.ServiceInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) ServicesReturnsOnCall(i int, result1 v1.ServiceInterface) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 v1.ServiceInterface
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 v1.ServiceInterface
	}{result1}
}

func (fake *FakeCoreV1Interface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.componentStatusesMutex.RLock()
	defer fake.componentStatusesMutex.RUnlock()
	fake.configMapsMutex.RLock()
	defer fake.configMapsMutex.RUnlock()
	fake.endpointsMutex.RLock()
	defer fake.endpointsMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.limitRangesMutex.RLock()
	defer fake.limitRangesMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.nodesMutex.RLock()
	defer fake.nodesMutex.RUnlock()
	fake.persistentVolumeClaimsMutex.RLock()
	defer fake.persistentVolumeClaimsMutex.RUnlock()
	fake.persistentVolumesMutex.RLock()
	defer fake.persistentVolumesMutex.RUnlock()
	fake.podTemplatesMutex.RLock()
	defer fake.podTemplatesMutex.RUnlock()
	fake.podsMutex.RLock()
	defer fake.podsMutex.RUnlock()
	fake.rESTClientMutex.RLock()
	defer fake.rESTClientMutex.RUnlock()
	fake.replicationControllersMutex.RLock()
	defer fake.replicationControllersMutex.RUnlock()
	fake.resourceQuotasMutex.RLock()
	defer fake.resourceQuotasMutex.RUnlock()
	fake.secretsMutex.RLock()
	defer fake.secretsMutex.RUnlock()
	fake.serviceAccountsMutex.RLock()
	defer fake.serviceAccountsMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCoreV1Interface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v1.CoreV1Interface = new(FakeCoreV1Interface)

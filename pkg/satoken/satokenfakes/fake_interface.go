// Code generated by counterfeiter. DO NOT EDIT.
package satokenfakes

import (
	"sync"

	"k8s.io/client-go/discovery"
	"k8s.io/client-go/kubernetes"
	v1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1"
	"k8s.io/client-go/kubernetes/typed/admissionregistration/v1beta1"
	v1alpha1a "k8s.io/client-go/kubernetes/typed/apiserverinternal/v1alpha1"
	v1a "k8s.io/client-go/kubernetes/typed/apps/v1"
	v1beta1a "k8s.io/client-go/kubernetes/typed/apps/v1beta1"
	"k8s.io/client-go/kubernetes/typed/apps/v1beta2"
	v1b "k8s.io/client-go/kubernetes/typed/authentication/v1"
	v1beta1b "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
	v1c "k8s.io/client-go/kubernetes/typed/authorization/v1"
	v1beta1c "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
	v1d "k8s.io/client-go/kubernetes/typed/autoscaling/v1"
	v2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2"
	"k8s.io/client-go/kubernetes/typed/autoscaling/v2beta1"
	"k8s.io/client-go/kubernetes/typed/autoscaling/v2beta2"
	v1e "k8s.io/client-go/kubernetes/typed/batch/v1"
	v1beta1d "k8s.io/client-go/kubernetes/typed/batch/v1beta1"
	v1f "k8s.io/client-go/kubernetes/typed/certificates/v1"
	v1beta1e "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
	v1g "k8s.io/client-go/kubernetes/typed/coordination/v1"
	v1beta1f "k8s.io/client-go/kubernetes/typed/coordination/v1beta1"
	v1h "k8s.io/client-go/kubernetes/typed/core/v1"
	v1i "k8s.io/client-go/kubernetes/typed/discovery/v1"
	v1beta1g "k8s.io/client-go/kubernetes/typed/discovery/v1beta1"
	v1j "k8s.io/client-go/kubernetes/typed/events/v1"
	v1beta1h "k8s.io/client-go/kubernetes/typed/events/v1beta1"
	v1beta1i "k8s.io/client-go/kubernetes/typed/extensions/v1beta1"
	"k8s.io/client-go/kubernetes/typed/flowcontrol/v1alpha1"
	v1beta1j "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta1"
	v1beta2a "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta2"
	v1k "k8s.io/client-go/kubernetes/typed/networking/v1"
	v1alpha1b "k8s.io/client-go/kubernetes/typed/networking/v1alpha1"
	v1beta1k "k8s.io/client-go/kubernetes/typed/networking/v1beta1"
	v1l "k8s.io/client-go/kubernetes/typed/node/v1"
	v1alpha1c "k8s.io/client-go/kubernetes/typed/node/v1alpha1"
	v1beta1l "k8s.io/client-go/kubernetes/typed/node/v1beta1"
	v1m "k8s.io/client-go/kubernetes/typed/policy/v1"
	v1beta1m "k8s.io/client-go/kubernetes/typed/policy/v1beta1"
	v1n "k8s.io/client-go/kubernetes/typed/rbac/v1"
	v1alpha1d "k8s.io/client-go/kubernetes/typed/rbac/v1alpha1"
	v1beta1n "k8s.io/client-go/kubernetes/typed/rbac/v1beta1"
	v1o "k8s.io/client-go/kubernetes/typed/scheduling/v1"
	v1alpha1e "k8s.io/client-go/kubernetes/typed/scheduling/v1alpha1"
	v1beta1o "k8s.io/client-go/kubernetes/typed/scheduling/v1beta1"
	v1p "k8s.io/client-go/kubernetes/typed/storage/v1"
	v1alpha1f "k8s.io/client-go/kubernetes/typed/storage/v1alpha1"
	v1beta1p "k8s.io/client-go/kubernetes/typed/storage/v1beta1"
)

type FakeInterface struct {
	AdmissionregistrationV1Stub        func() v1.AdmissionregistrationV1Interface
	admissionregistrationV1Mutex       sync.RWMutex
	admissionregistrationV1ArgsForCall []struct {
	}
	admissionregistrationV1Returns struct {
		result1 v1.AdmissionregistrationV1Interface
	}
	admissionregistrationV1ReturnsOnCall map[int]struct {
		result1 v1.AdmissionregistrationV1Interface
	}
	AdmissionregistrationV1beta1Stub        func() v1beta1.AdmissionregistrationV1beta1Interface
	admissionregistrationV1beta1Mutex       sync.RWMutex
	admissionregistrationV1beta1ArgsForCall []struct {
	}
	admissionregistrationV1beta1Returns struct {
		result1 v1beta1.AdmissionregistrationV1beta1Interface
	}
	admissionregistrationV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1.AdmissionregistrationV1beta1Interface
	}
	AppsV1Stub        func() v1a.AppsV1Interface
	appsV1Mutex       sync.RWMutex
	appsV1ArgsForCall []struct {
	}
	appsV1Returns struct {
		result1 v1a.AppsV1Interface
	}
	appsV1ReturnsOnCall map[int]struct {
		result1 v1a.AppsV1Interface
	}
	AppsV1beta1Stub        func() v1beta1a.AppsV1beta1Interface
	appsV1beta1Mutex       sync.RWMutex
	appsV1beta1ArgsForCall []struct {
	}
	appsV1beta1Returns struct {
		result1 v1beta1a.AppsV1beta1Interface
	}
	appsV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1a.AppsV1beta1Interface
	}
	AppsV1beta2Stub        func() v1beta2.AppsV1beta2Interface
	appsV1beta2Mutex       sync.RWMutex
	appsV1beta2ArgsForCall []struct {
	}
	appsV1beta2Returns struct {
		result1 v1beta2.AppsV1beta2Interface
	}
	appsV1beta2ReturnsOnCall map[int]struct {
		result1 v1beta2.AppsV1beta2Interface
	}
	AuthenticationV1Stub        func() v1b.AuthenticationV1Interface
	authenticationV1Mutex       sync.RWMutex
	authenticationV1ArgsForCall []struct {
	}
	authenticationV1Returns struct {
		result1 v1b.AuthenticationV1Interface
	}
	authenticationV1ReturnsOnCall map[int]struct {
		result1 v1b.AuthenticationV1Interface
	}
	AuthenticationV1beta1Stub        func() v1beta1b.AuthenticationV1beta1Interface
	authenticationV1beta1Mutex       sync.RWMutex
	authenticationV1beta1ArgsForCall []struct {
	}
	authenticationV1beta1Returns struct {
		result1 v1beta1b.AuthenticationV1beta1Interface
	}
	authenticationV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1b.AuthenticationV1beta1Interface
	}
	AuthorizationV1Stub        func() v1c.AuthorizationV1Interface
	authorizationV1Mutex       sync.RWMutex
	authorizationV1ArgsForCall []struct {
	}
	authorizationV1Returns struct {
		result1 v1c.AuthorizationV1Interface
	}
	authorizationV1ReturnsOnCall map[int]struct {
		result1 v1c.AuthorizationV1Interface
	}
	AuthorizationV1beta1Stub        func() v1beta1c.AuthorizationV1beta1Interface
	authorizationV1beta1Mutex       sync.RWMutex
	authorizationV1beta1ArgsForCall []struct {
	}
	authorizationV1beta1Returns struct {
		result1 v1beta1c.AuthorizationV1beta1Interface
	}
	authorizationV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1c.AuthorizationV1beta1Interface
	}
	AutoscalingV1Stub        func() v1d.AutoscalingV1Interface
	autoscalingV1Mutex       sync.RWMutex
	autoscalingV1ArgsForCall []struct {
	}
	autoscalingV1Returns struct {
		result1 v1d.AutoscalingV1Interface
	}
	autoscalingV1ReturnsOnCall map[int]struct {
		result1 v1d.AutoscalingV1Interface
	}
	AutoscalingV2Stub        func() v2.AutoscalingV2Interface
	autoscalingV2Mutex       sync.RWMutex
	autoscalingV2ArgsForCall []struct {
	}
	autoscalingV2Returns struct {
		result1 v2.AutoscalingV2Interface
	}
	autoscalingV2ReturnsOnCall map[int]struct {
		result1 v2.AutoscalingV2Interface
	}
	AutoscalingV2beta1Stub        func() v2beta1.AutoscalingV2beta1Interface
	autoscalingV2beta1Mutex       sync.RWMutex
	autoscalingV2beta1ArgsForCall []struct {
	}
	autoscalingV2beta1Returns struct {
		result1 v2beta1.AutoscalingV2beta1Interface
	}
	autoscalingV2beta1ReturnsOnCall map[int]struct {
		result1 v2beta1.AutoscalingV2beta1Interface
	}
	AutoscalingV2beta2Stub        func() v2beta2.AutoscalingV2beta2Interface
	autoscalingV2beta2Mutex       sync.RWMutex
	autoscalingV2beta2ArgsForCall []struct {
	}
	autoscalingV2beta2Returns struct {
		result1 v2beta2.AutoscalingV2beta2Interface
	}
	autoscalingV2beta2ReturnsOnCall map[int]struct {
		result1 v2beta2.AutoscalingV2beta2Interface
	}
	BatchV1Stub        func() v1e.BatchV1Interface
	batchV1Mutex       sync.RWMutex
	batchV1ArgsForCall []struct {
	}
	batchV1Returns struct {
		result1 v1e.BatchV1Interface
	}
	batchV1ReturnsOnCall map[int]struct {
		result1 v1e.BatchV1Interface
	}
	BatchV1beta1Stub        func() v1beta1d.BatchV1beta1Interface
	batchV1beta1Mutex       sync.RWMutex
	batchV1beta1ArgsForCall []struct {
	}
	batchV1beta1Returns struct {
		result1 v1beta1d.BatchV1beta1Interface
	}
	batchV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1d.BatchV1beta1Interface
	}
	CertificatesV1Stub        func() v1f.CertificatesV1Interface
	certificatesV1Mutex       sync.RWMutex
	certificatesV1ArgsForCall []struct {
	}
	certificatesV1Returns struct {
		result1 v1f.CertificatesV1Interface
	}
	certificatesV1ReturnsOnCall map[int]struct {
		result1 v1f.CertificatesV1Interface
	}
	CertificatesV1beta1Stub        func() v1beta1e.CertificatesV1beta1Interface
	certificatesV1beta1Mutex       sync.RWMutex
	certificatesV1beta1ArgsForCall []struct {
	}
	certificatesV1beta1Returns struct {
		result1 v1beta1e.CertificatesV1beta1Interface
	}
	certificatesV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1e.CertificatesV1beta1Interface
	}
	CoordinationV1Stub        func() v1g.CoordinationV1Interface
	coordinationV1Mutex       sync.RWMutex
	coordinationV1ArgsForCall []struct {
	}
	coordinationV1Returns struct {
		result1 v1g.CoordinationV1Interface
	}
	coordinationV1ReturnsOnCall map[int]struct {
		result1 v1g.CoordinationV1Interface
	}
	CoordinationV1beta1Stub        func() v1beta1f.CoordinationV1beta1Interface
	coordinationV1beta1Mutex       sync.RWMutex
	coordinationV1beta1ArgsForCall []struct {
	}
	coordinationV1beta1Returns struct {
		result1 v1beta1f.CoordinationV1beta1Interface
	}
	coordinationV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1f.CoordinationV1beta1Interface
	}
	CoreV1Stub        func() v1h.CoreV1Interface
	coreV1Mutex       sync.RWMutex
	coreV1ArgsForCall []struct {
	}
	coreV1Returns struct {
		result1 v1h.CoreV1Interface
	}
	coreV1ReturnsOnCall map[int]struct {
		result1 v1h.CoreV1Interface
	}
	DiscoveryStub        func() discovery.DiscoveryInterface
	discoveryMutex       sync.RWMutex
	discoveryArgsForCall []struct {
	}
	discoveryReturns struct {
		result1 discovery.DiscoveryInterface
	}
	discoveryReturnsOnCall map[int]struct {
		result1 discovery.DiscoveryInterface
	}
	DiscoveryV1Stub        func() v1i.DiscoveryV1Interface
	discoveryV1Mutex       sync.RWMutex
	discoveryV1ArgsForCall []struct {
	}
	discoveryV1Returns struct {
		result1 v1i.DiscoveryV1Interface
	}
	discoveryV1ReturnsOnCall map[int]struct {
		result1 v1i.DiscoveryV1Interface
	}
	DiscoveryV1beta1Stub        func() v1beta1g.DiscoveryV1beta1Interface
	discoveryV1beta1Mutex       sync.RWMutex
	discoveryV1beta1ArgsForCall []struct {
	}
	discoveryV1beta1Returns struct {
		result1 v1beta1g.DiscoveryV1beta1Interface
	}
	discoveryV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1g.DiscoveryV1beta1Interface
	}
	EventsV1Stub        func() v1j.EventsV1Interface
	eventsV1Mutex       sync.RWMutex
	eventsV1ArgsForCall []struct {
	}
	eventsV1Returns struct {
		result1 v1j.EventsV1Interface
	}
	eventsV1ReturnsOnCall map[int]struct {
		result1 v1j.EventsV1Interface
	}
	EventsV1beta1Stub        func() v1beta1h.EventsV1beta1Interface
	eventsV1beta1Mutex       sync.RWMutex
	eventsV1beta1ArgsForCall []struct {
	}
	eventsV1beta1Returns struct {
		result1 v1beta1h.EventsV1beta1Interface
	}
	eventsV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1h.EventsV1beta1Interface
	}
	ExtensionsV1beta1Stub        func() v1beta1i.ExtensionsV1beta1Interface
	extensionsV1beta1Mutex       sync.RWMutex
	extensionsV1beta1ArgsForCall []struct {
	}
	extensionsV1beta1Returns struct {
		result1 v1beta1i.ExtensionsV1beta1Interface
	}
	extensionsV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1i.ExtensionsV1beta1Interface
	}
	FlowcontrolV1alpha1Stub        func() v1alpha1.FlowcontrolV1alpha1Interface
	flowcontrolV1alpha1Mutex       sync.RWMutex
	flowcontrolV1alpha1ArgsForCall []struct {
	}
	flowcontrolV1alpha1Returns struct {
		result1 v1alpha1.FlowcontrolV1alpha1Interface
	}
	flowcontrolV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1.FlowcontrolV1alpha1Interface
	}
	FlowcontrolV1beta1Stub        func() v1beta1j.FlowcontrolV1beta1Interface
	flowcontrolV1beta1Mutex       sync.RWMutex
	flowcontrolV1beta1ArgsForCall []struct {
	}
	flowcontrolV1beta1Returns struct {
		result1 v1beta1j.FlowcontrolV1beta1Interface
	}
	flowcontrolV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1j.FlowcontrolV1beta1Interface
	}
	FlowcontrolV1beta2Stub        func() v1beta2a.FlowcontrolV1beta2Interface
	flowcontrolV1beta2Mutex       sync.RWMutex
	flowcontrolV1beta2ArgsForCall []struct {
	}
	flowcontrolV1beta2Returns struct {
		result1 v1beta2a.FlowcontrolV1beta2Interface
	}
	flowcontrolV1beta2ReturnsOnCall map[int]struct {
		result1 v1beta2a.FlowcontrolV1beta2Interface
	}
	InternalV1alpha1Stub        func() v1alpha1a.InternalV1alpha1Interface
	internalV1alpha1Mutex       sync.RWMutex
	internalV1alpha1ArgsForCall []struct {
	}
	internalV1alpha1Returns struct {
		result1 v1alpha1a.InternalV1alpha1Interface
	}
	internalV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1a.InternalV1alpha1Interface
	}
	NetworkingV1Stub        func() v1k.NetworkingV1Interface
	networkingV1Mutex       sync.RWMutex
	networkingV1ArgsForCall []struct {
	}
	networkingV1Returns struct {
		result1 v1k.NetworkingV1Interface
	}
	networkingV1ReturnsOnCall map[int]struct {
		result1 v1k.NetworkingV1Interface
	}
	NetworkingV1alpha1Stub        func() v1alpha1b.NetworkingV1alpha1Interface
	networkingV1alpha1Mutex       sync.RWMutex
	networkingV1alpha1ArgsForCall []struct {
	}
	networkingV1alpha1Returns struct {
		result1 v1alpha1b.NetworkingV1alpha1Interface
	}
	networkingV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1b.NetworkingV1alpha1Interface
	}
	NetworkingV1beta1Stub        func() v1beta1k.NetworkingV1beta1Interface
	networkingV1beta1Mutex       sync.RWMutex
	networkingV1beta1ArgsForCall []struct {
	}
	networkingV1beta1Returns struct {
		result1 v1beta1k.NetworkingV1beta1Interface
	}
	networkingV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1k.NetworkingV1beta1Interface
	}
	NodeV1Stub        func() v1l.NodeV1Interface
	nodeV1Mutex       sync.RWMutex
	nodeV1ArgsForCall []struct {
	}
	nodeV1Returns struct {
		result1 v1l.NodeV1Interface
	}
	nodeV1ReturnsOnCall map[int]struct {
		result1 v1l.NodeV1Interface
	}
	NodeV1alpha1Stub        func() v1alpha1c.NodeV1alpha1Interface
	nodeV1alpha1Mutex       sync.RWMutex
	nodeV1alpha1ArgsForCall []struct {
	}
	nodeV1alpha1Returns struct {
		result1 v1alpha1c.NodeV1alpha1Interface
	}
	nodeV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1c.NodeV1alpha1Interface
	}
	NodeV1beta1Stub        func() v1beta1l.NodeV1beta1Interface
	nodeV1beta1Mutex       sync.RWMutex
	nodeV1beta1ArgsForCall []struct {
	}
	nodeV1beta1Returns struct {
		result1 v1beta1l.NodeV1beta1Interface
	}
	nodeV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1l.NodeV1beta1Interface
	}
	PolicyV1Stub        func() v1m.PolicyV1Interface
	policyV1Mutex       sync.RWMutex
	policyV1ArgsForCall []struct {
	}
	policyV1Returns struct {
		result1 v1m.PolicyV1Interface
	}
	policyV1ReturnsOnCall map[int]struct {
		result1 v1m.PolicyV1Interface
	}
	PolicyV1beta1Stub        func() v1beta1m.PolicyV1beta1Interface
	policyV1beta1Mutex       sync.RWMutex
	policyV1beta1ArgsForCall []struct {
	}
	policyV1beta1Returns struct {
		result1 v1beta1m.PolicyV1beta1Interface
	}
	policyV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1m.PolicyV1beta1Interface
	}
	RbacV1Stub        func() v1n.RbacV1Interface
	rbacV1Mutex       sync.RWMutex
	rbacV1ArgsForCall []struct {
	}
	rbacV1Returns struct {
		result1 v1n.RbacV1Interface
	}
	rbacV1ReturnsOnCall map[int]struct {
		result1 v1n.RbacV1Interface
	}
	RbacV1alpha1Stub        func() v1alpha1d.RbacV1alpha1Interface
	rbacV1alpha1Mutex       sync.RWMutex
	rbacV1alpha1ArgsForCall []struct {
	}
	rbacV1alpha1Returns struct {
		result1 v1alpha1d.RbacV1alpha1Interface
	}
	rbacV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1d.RbacV1alpha1Interface
	}
	RbacV1beta1Stub        func() v1beta1n.RbacV1beta1Interface
	rbacV1beta1Mutex       sync.RWMutex
	rbacV1beta1ArgsForCall []struct {
	}
	rbacV1beta1Returns struct {
		result1 v1beta1n.RbacV1beta1Interface
	}
	rbacV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1n.RbacV1beta1Interface
	}
	SchedulingV1Stub        func() v1o.SchedulingV1Interface
	schedulingV1Mutex       sync.RWMutex
	schedulingV1ArgsForCall []struct {
	}
	schedulingV1Returns struct {
		result1 v1o.SchedulingV1Interface
	}
	schedulingV1ReturnsOnCall map[int]struct {
		result1 v1o.SchedulingV1Interface
	}
	SchedulingV1alpha1Stub        func() v1alpha1e.SchedulingV1alpha1Interface
	schedulingV1alpha1Mutex       sync.RWMutex
	schedulingV1alpha1ArgsForCall []struct {
	}
	schedulingV1alpha1Returns struct {
		result1 v1alpha1e.SchedulingV1alpha1Interface
	}
	schedulingV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1e.SchedulingV1alpha1Interface
	}
	SchedulingV1beta1Stub        func() v1beta1o.SchedulingV1beta1Interface
	schedulingV1beta1Mutex       sync.RWMutex
	schedulingV1beta1ArgsForCall []struct {
	}
	schedulingV1beta1Returns struct {
		result1 v1beta1o.SchedulingV1beta1Interface
	}
	schedulingV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1o.SchedulingV1beta1Interface
	}
	StorageV1Stub        func() v1p.StorageV1Interface
	storageV1Mutex       sync.RWMutex
	storageV1ArgsForCall []struct {
	}
	storageV1Returns struct {
		result1 v1p.StorageV1Interface
	}
	storageV1ReturnsOnCall map[int]struct {
		result1 v1p.StorageV1Interface
	}
	StorageV1alpha1Stub        func() v1alpha1f.StorageV1alpha1Interface
	storageV1alpha1Mutex       sync.RWMutex
	storageV1alpha1ArgsForCall []struct {
	}
	storageV1alpha1Returns struct {
		result1 v1alpha1f.StorageV1alpha1Interface
	}
	storageV1alpha1ReturnsOnCall map[int]struct {
		result1 v1alpha1f.StorageV1alpha1Interface
	}
	StorageV1beta1Stub        func() v1beta1p.StorageV1beta1Interface
	storageV1beta1Mutex       sync.RWMutex
	storageV1beta1ArgsForCall []struct {
	}
	storageV1beta1Returns struct {
		result1 v1beta1p.StorageV1beta1Interface
	}
	storageV1beta1ReturnsOnCall map[int]struct {
		result1 v1beta1p.StorageV1beta1Interface
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInterface) AdmissionregistrationV1() v1.AdmissionregistrationV1Interface {
	fake.admissionregistrationV1Mutex.Lock()
	ret, specificReturn := fake.admissionregistrationV1ReturnsOnCall[len(fake.admissionregistrationV1ArgsForCall)]
	fake.admissionregistrationV1ArgsForCall = append(fake.admissionregistrationV1ArgsForCall, struct {
	}{})
	stub := fake.AdmissionregistrationV1Stub
	fakeReturns := fake.admissionregistrationV1Returns
	fake.recordInvocation("AdmissionregistrationV1", []interface{}{})
	fake.admissionregistrationV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AdmissionregistrationV1CallCount() int {
	fake.admissionregistrationV1Mutex.RLock()
	defer fake.admissionregistrationV1Mutex.RUnlock()
	return len(fake.admissionregistrationV1ArgsForCall)
}

func (fake *FakeInterface) AdmissionregistrationV1Calls(stub func() v1.AdmissionregistrationV1Interface) {
	fake.admissionregistrationV1Mutex.Lock()
	defer fake.admissionregistrationV1Mutex.Unlock()
	fake.AdmissionregistrationV1Stub = stub
}

func (fake *FakeInterface) AdmissionregistrationV1Returns(result1 v1.AdmissionregistrationV1Interface) {
	fake.admissionregistrationV1Mutex.Lock()
	defer fake.admissionregistrationV1Mutex.Unlock()
	fake.AdmissionregistrationV1Stub = nil
	fake.admissionregistrationV1Returns = struct {
		result1 v1.AdmissionregistrationV1Interface
	}{result1}
}

func (fake *FakeInterface) AdmissionregistrationV1ReturnsOnCall(i int, result1 v1.AdmissionregistrationV1Interface) {
	fake.admissionregistrationV1Mutex.Lock()
	defer fake.admissionregistrationV1Mutex.Unlock()
	fake.AdmissionregistrationV1Stub = nil
	if fake.admissionregistrationV1ReturnsOnCall == nil {
		fake.admissionregistrationV1ReturnsOnCall = make(map[int]struct {
			result1 v1.AdmissionregistrationV1Interface
		})
	}
	fake.admissionregistrationV1ReturnsOnCall[i] = struct {
		result1 v1.AdmissionregistrationV1Interface
	}{result1}
}

func (fake *FakeInterface) AdmissionregistrationV1beta1() v1beta1.AdmissionregistrationV1beta1Interface {
	fake.admissionregistrationV1beta1Mutex.Lock()
	ret, specificReturn := fake.admissionregistrationV1beta1ReturnsOnCall[len(fake.admissionregistrationV1beta1ArgsForCall)]
	fake.admissionregistrationV1beta1ArgsForCall = append(fake.admissionregistrationV1beta1ArgsForCall, struct {
	}{})
	stub := fake.AdmissionregistrationV1beta1Stub
	fakeReturns := fake.admissionregistrationV1beta1Returns
	fake.recordInvocation("AdmissionregistrationV1beta1", []interface{}{})
	fake.admissionregistrationV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AdmissionregistrationV1beta1CallCount() int {
	fake.admissionregistrationV1beta1Mutex.RLock()
	defer fake.admissionregistrationV1beta1Mutex.RUnlock()
	return len(fake.admissionregistrationV1beta1ArgsForCall)
}

func (fake *FakeInterface) AdmissionregistrationV1beta1Calls(stub func() v1beta1.AdmissionregistrationV1beta1Interface) {
	fake.admissionregistrationV1beta1Mutex.Lock()
	defer fake.admissionregistrationV1beta1Mutex.Unlock()
	fake.AdmissionregistrationV1beta1Stub = stub
}

func (fake *FakeInterface) AdmissionregistrationV1beta1Returns(result1 v1beta1.AdmissionregistrationV1beta1Interface) {
	fake.admissionregistrationV1beta1Mutex.Lock()
	defer fake.admissionregistrationV1beta1Mutex.Unlock()
	fake.AdmissionregistrationV1beta1Stub = nil
	fake.admissionregistrationV1beta1Returns = struct {
		result1 v1beta1.AdmissionregistrationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AdmissionregistrationV1beta1ReturnsOnCall(i int, result1 v1beta1.AdmissionregistrationV1beta1Interface) {
	fake.admissionregistrationV1beta1Mutex.Lock()
	defer fake.admissionregistrationV1beta1Mutex.Unlock()
	fake.AdmissionregistrationV1beta1Stub = nil
	if fake.admissionregistrationV1beta1ReturnsOnCall == nil {
		fake.admissionregistrationV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1.AdmissionregistrationV1beta1Interface
		})
	}
	fake.admissionregistrationV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1.AdmissionregistrationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1() v1a.AppsV1Interface {
	fake.appsV1Mutex.Lock()
	ret, specificReturn := fake.appsV1ReturnsOnCall[len(fake.appsV1ArgsForCall)]
	fake.appsV1ArgsForCall = append(fake.appsV1ArgsForCall, struct {
	}{})
	stub := fake.AppsV1Stub
	fakeReturns := fake.appsV1Returns
	fake.recordInvocation("AppsV1", []interface{}{})
	fake.appsV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AppsV1CallCount() int {
	fake.appsV1Mutex.RLock()
	defer fake.appsV1Mutex.RUnlock()
	return len(fake.appsV1ArgsForCall)
}

func (fake *FakeInterface) AppsV1Calls(stub func() v1a.AppsV1Interface) {
	fake.appsV1Mutex.Lock()
	defer fake.appsV1Mutex.Unlock()
	fake.AppsV1Stub = stub
}

func (fake *FakeInterface) AppsV1Returns(result1 v1a.AppsV1Interface) {
	fake.appsV1Mutex.Lock()
	defer fake.appsV1Mutex.Unlock()
	fake.AppsV1Stub = nil
	fake.appsV1Returns = struct {
		result1 v1a.AppsV1Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1ReturnsOnCall(i int, result1 v1a.AppsV1Interface) {
	fake.appsV1Mutex.Lock()
	defer fake.appsV1Mutex.Unlock()
	fake.AppsV1Stub = nil
	if fake.appsV1ReturnsOnCall == nil {
		fake.appsV1ReturnsOnCall = make(map[int]struct {
			result1 v1a.AppsV1Interface
		})
	}
	fake.appsV1ReturnsOnCall[i] = struct {
		result1 v1a.AppsV1Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1beta1() v1beta1a.AppsV1beta1Interface {
	fake.appsV1beta1Mutex.Lock()
	ret, specificReturn := fake.appsV1beta1ReturnsOnCall[len(fake.appsV1beta1ArgsForCall)]
	fake.appsV1beta1ArgsForCall = append(fake.appsV1beta1ArgsForCall, struct {
	}{})
	stub := fake.AppsV1beta1Stub
	fakeReturns := fake.appsV1beta1Returns
	fake.recordInvocation("AppsV1beta1", []interface{}{})
	fake.appsV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AppsV1beta1CallCount() int {
	fake.appsV1beta1Mutex.RLock()
	defer fake.appsV1beta1Mutex.RUnlock()
	return len(fake.appsV1beta1ArgsForCall)
}

func (fake *FakeInterface) AppsV1beta1Calls(stub func() v1beta1a.AppsV1beta1Interface) {
	fake.appsV1beta1Mutex.Lock()
	defer fake.appsV1beta1Mutex.Unlock()
	fake.AppsV1beta1Stub = stub
}

func (fake *FakeInterface) AppsV1beta1Returns(result1 v1beta1a.AppsV1beta1Interface) {
	fake.appsV1beta1Mutex.Lock()
	defer fake.appsV1beta1Mutex.Unlock()
	fake.AppsV1beta1Stub = nil
	fake.appsV1beta1Returns = struct {
		result1 v1beta1a.AppsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1beta1ReturnsOnCall(i int, result1 v1beta1a.AppsV1beta1Interface) {
	fake.appsV1beta1Mutex.Lock()
	defer fake.appsV1beta1Mutex.Unlock()
	fake.AppsV1beta1Stub = nil
	if fake.appsV1beta1ReturnsOnCall == nil {
		fake.appsV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1a.AppsV1beta1Interface
		})
	}
	fake.appsV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1a.AppsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1beta2() v1beta2.AppsV1beta2Interface {
	fake.appsV1beta2Mutex.Lock()
	ret, specificReturn := fake.appsV1beta2ReturnsOnCall[len(fake.appsV1beta2ArgsForCall)]
	fake.appsV1beta2ArgsForCall = append(fake.appsV1beta2ArgsForCall, struct {
	}{})
	stub := fake.AppsV1beta2Stub
	fakeReturns := fake.appsV1beta2Returns
	fake.recordInvocation("AppsV1beta2", []interface{}{})
	fake.appsV1beta2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AppsV1beta2CallCount() int {
	fake.appsV1beta2Mutex.RLock()
	defer fake.appsV1beta2Mutex.RUnlock()
	return len(fake.appsV1beta2ArgsForCall)
}

func (fake *FakeInterface) AppsV1beta2Calls(stub func() v1beta2.AppsV1beta2Interface) {
	fake.appsV1beta2Mutex.Lock()
	defer fake.appsV1beta2Mutex.Unlock()
	fake.AppsV1beta2Stub = stub
}

func (fake *FakeInterface) AppsV1beta2Returns(result1 v1beta2.AppsV1beta2Interface) {
	fake.appsV1beta2Mutex.Lock()
	defer fake.appsV1beta2Mutex.Unlock()
	fake.AppsV1beta2Stub = nil
	fake.appsV1beta2Returns = struct {
		result1 v1beta2.AppsV1beta2Interface
	}{result1}
}

func (fake *FakeInterface) AppsV1beta2ReturnsOnCall(i int, result1 v1beta2.AppsV1beta2Interface) {
	fake.appsV1beta2Mutex.Lock()
	defer fake.appsV1beta2Mutex.Unlock()
	fake.AppsV1beta2Stub = nil
	if fake.appsV1beta2ReturnsOnCall == nil {
		fake.appsV1beta2ReturnsOnCall = make(map[int]struct {
			result1 v1beta2.AppsV1beta2Interface
		})
	}
	fake.appsV1beta2ReturnsOnCall[i] = struct {
		result1 v1beta2.AppsV1beta2Interface
	}{result1}
}

func (fake *FakeInterface) AuthenticationV1() v1b.AuthenticationV1Interface {
	fake.authenticationV1Mutex.Lock()
	ret, specificReturn := fake.authenticationV1ReturnsOnCall[len(fake.authenticationV1ArgsForCall)]
	fake.authenticationV1ArgsForCall = append(fake.authenticationV1ArgsForCall, struct {
	}{})
	stub := fake.AuthenticationV1Stub
	fakeReturns := fake.authenticationV1Returns
	fake.recordInvocation("AuthenticationV1", []interface{}{})
	fake.authenticationV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AuthenticationV1CallCount() int {
	fake.authenticationV1Mutex.RLock()
	defer fake.authenticationV1Mutex.RUnlock()
	return len(fake.authenticationV1ArgsForCall)
}

func (fake *FakeInterface) AuthenticationV1Calls(stub func() v1b.AuthenticationV1Interface) {
	fake.authenticationV1Mutex.Lock()
	defer fake.authenticationV1Mutex.Unlock()
	fake.AuthenticationV1Stub = stub
}

func (fake *FakeInterface) AuthenticationV1Returns(result1 v1b.AuthenticationV1Interface) {
	fake.authenticationV1Mutex.Lock()
	defer fake.authenticationV1Mutex.Unlock()
	fake.AuthenticationV1Stub = nil
	fake.authenticationV1Returns = struct {
		result1 v1b.AuthenticationV1Interface
	}{result1}
}

func (fake *FakeInterface) AuthenticationV1ReturnsOnCall(i int, result1 v1b.AuthenticationV1Interface) {
	fake.authenticationV1Mutex.Lock()
	defer fake.authenticationV1Mutex.Unlock()
	fake.AuthenticationV1Stub = nil
	if fake.authenticationV1ReturnsOnCall == nil {
		fake.authenticationV1ReturnsOnCall = make(map[int]struct {
			result1 v1b.AuthenticationV1Interface
		})
	}
	fake.authenticationV1ReturnsOnCall[i] = struct {
		result1 v1b.AuthenticationV1Interface
	}{result1}
}

func (fake *FakeInterface) AuthenticationV1beta1() v1beta1b.AuthenticationV1beta1Interface {
	fake.authenticationV1beta1Mutex.Lock()
	ret, specificReturn := fake.authenticationV1beta1ReturnsOnCall[len(fake.authenticationV1beta1ArgsForCall)]
	fake.authenticationV1beta1ArgsForCall = append(fake.authenticationV1beta1ArgsForCall, struct {
	}{})
	stub := fake.AuthenticationV1beta1Stub
	fakeReturns := fake.authenticationV1beta1Returns
	fake.recordInvocation("AuthenticationV1beta1", []interface{}{})
	fake.authenticationV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AuthenticationV1beta1CallCount() int {
	fake.authenticationV1beta1Mutex.RLock()
	defer fake.authenticationV1beta1Mutex.RUnlock()
	return len(fake.authenticationV1beta1ArgsForCall)
}

func (fake *FakeInterface) AuthenticationV1beta1Calls(stub func() v1beta1b.AuthenticationV1beta1Interface) {
	fake.authenticationV1beta1Mutex.Lock()
	defer fake.authenticationV1beta1Mutex.Unlock()
	fake.AuthenticationV1beta1Stub = stub
}

func (fake *FakeInterface) AuthenticationV1beta1Returns(result1 v1beta1b.AuthenticationV1beta1Interface) {
	fake.authenticationV1beta1Mutex.Lock()
	defer fake.authenticationV1beta1Mutex.Unlock()
	fake.AuthenticationV1beta1Stub = nil
	fake.authenticationV1beta1Returns = struct {
		result1 v1beta1b.AuthenticationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AuthenticationV1beta1ReturnsOnCall(i int, result1 v1beta1b.AuthenticationV1beta1Interface) {
	fake.authenticationV1beta1Mutex.Lock()
	defer fake.authenticationV1beta1Mutex.Unlock()
	fake.AuthenticationV1beta1Stub = nil
	if fake.authenticationV1beta1ReturnsOnCall == nil {
		fake.authenticationV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1b.AuthenticationV1beta1Interface
		})
	}
	fake.authenticationV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1b.AuthenticationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AuthorizationV1() v1c.AuthorizationV1Interface {
	fake.authorizationV1Mutex.Lock()
	ret, specificReturn := fake.authorizationV1ReturnsOnCall[len(fake.authorizationV1ArgsForCall)]
	fake.authorizationV1ArgsForCall = append(fake.authorizationV1ArgsForCall, struct {
	}{})
	stub := fake.AuthorizationV1Stub
	fakeReturns := fake.authorizationV1Returns
	fake.recordInvocation("AuthorizationV1", []interface{}{})
	fake.authorizationV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AuthorizationV1CallCount() int {
	fake.authorizationV1Mutex.RLock()
	defer fake.authorizationV1Mutex.RUnlock()
	return len(fake.authorizationV1ArgsForCall)
}

func (fake *FakeInterface) AuthorizationV1Calls(stub func() v1c.AuthorizationV1Interface) {
	fake.authorizationV1Mutex.Lock()
	defer fake.authorizationV1Mutex.Unlock()
	fake.AuthorizationV1Stub = stub
}

func (fake *FakeInterface) AuthorizationV1Returns(result1 v1c.AuthorizationV1Interface) {
	fake.authorizationV1Mutex.Lock()
	defer fake.authorizationV1Mutex.Unlock()
	fake.AuthorizationV1Stub = nil
	fake.authorizationV1Returns = struct {
		result1 v1c.AuthorizationV1Interface
	}{result1}
}

func (fake *FakeInterface) AuthorizationV1ReturnsOnCall(i int, result1 v1c.AuthorizationV1Interface) {
	fake.authorizationV1Mutex.Lock()
	defer fake.authorizationV1Mutex.Unlock()
	fake.AuthorizationV1Stub = nil
	if fake.authorizationV1ReturnsOnCall == nil {
		fake.authorizationV1ReturnsOnCall = make(map[int]struct {
			result1 v1c.AuthorizationV1Interface
		})
	}
	fake.authorizationV1ReturnsOnCall[i] = struct {
		result1 v1c.AuthorizationV1Interface
	}{result1}
}

func (fake *FakeInterface) AuthorizationV1beta1() v1beta1c.AuthorizationV1beta1Interface {
	fake.authorizationV1beta1Mutex.Lock()
	ret, specificReturn := fake.authorizationV1beta1ReturnsOnCall[len(fake.authorizationV1beta1ArgsForCall)]
	fake.authorizationV1beta1ArgsForCall = append(fake.authorizationV1beta1ArgsForCall, struct {
	}{})
	stub := fake.AuthorizationV1beta1Stub
	fakeReturns := fake.authorizationV1beta1Returns
	fake.recordInvocation("AuthorizationV1beta1", []interface{}{})
	fake.authorizationV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AuthorizationV1beta1CallCount() int {
	fake.authorizationV1beta1Mutex.RLock()
	defer fake.authorizationV1beta1Mutex.RUnlock()
	return len(fake.authorizationV1beta1ArgsForCall)
}

func (fake *FakeInterface) AuthorizationV1beta1Calls(stub func() v1beta1c.AuthorizationV1beta1Interface) {
	fake.authorizationV1beta1Mutex.Lock()
	defer fake.authorizationV1beta1Mutex.Unlock()
	fake.AuthorizationV1beta1Stub = stub
}

func (fake *FakeInterface) AuthorizationV1beta1Returns(result1 v1beta1c.AuthorizationV1beta1Interface) {
	fake.authorizationV1beta1Mutex.Lock()
	defer fake.authorizationV1beta1Mutex.Unlock()
	fake.AuthorizationV1beta1Stub = nil
	fake.authorizationV1beta1Returns = struct {
		result1 v1beta1c.AuthorizationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AuthorizationV1beta1ReturnsOnCall(i int, result1 v1beta1c.AuthorizationV1beta1Interface) {
	fake.authorizationV1beta1Mutex.Lock()
	defer fake.authorizationV1beta1Mutex.Unlock()
	fake.AuthorizationV1beta1Stub = nil
	if fake.authorizationV1beta1ReturnsOnCall == nil {
		fake.authorizationV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1c.AuthorizationV1beta1Interface
		})
	}
	fake.authorizationV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1c.AuthorizationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV1() v1d.AutoscalingV1Interface {
	fake.autoscalingV1Mutex.Lock()
	ret, specificReturn := fake.autoscalingV1ReturnsOnCall[len(fake.autoscalingV1ArgsForCall)]
	fake.autoscalingV1ArgsForCall = append(fake.autoscalingV1ArgsForCall, struct {
	}{})
	stub := fake.AutoscalingV1Stub
	fakeReturns := fake.autoscalingV1Returns
	fake.recordInvocation("AutoscalingV1", []interface{}{})
	fake.autoscalingV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AutoscalingV1CallCount() int {
	fake.autoscalingV1Mutex.RLock()
	defer fake.autoscalingV1Mutex.RUnlock()
	return len(fake.autoscalingV1ArgsForCall)
}

func (fake *FakeInterface) AutoscalingV1Calls(stub func() v1d.AutoscalingV1Interface) {
	fake.autoscalingV1Mutex.Lock()
	defer fake.autoscalingV1Mutex.Unlock()
	fake.AutoscalingV1Stub = stub
}

func (fake *FakeInterface) AutoscalingV1Returns(result1 v1d.AutoscalingV1Interface) {
	fake.autoscalingV1Mutex.Lock()
	defer fake.autoscalingV1Mutex.Unlock()
	fake.AutoscalingV1Stub = nil
	fake.autoscalingV1Returns = struct {
		result1 v1d.AutoscalingV1Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV1ReturnsOnCall(i int, result1 v1d.AutoscalingV1Interface) {
	fake.autoscalingV1Mutex.Lock()
	defer fake.autoscalingV1Mutex.Unlock()
	fake.AutoscalingV1Stub = nil
	if fake.autoscalingV1ReturnsOnCall == nil {
		fake.autoscalingV1ReturnsOnCall = make(map[int]struct {
			result1 v1d.AutoscalingV1Interface
		})
	}
	fake.autoscalingV1ReturnsOnCall[i] = struct {
		result1 v1d.AutoscalingV1Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2() v2.AutoscalingV2Interface {
	fake.autoscalingV2Mutex.Lock()
	ret, specificReturn := fake.autoscalingV2ReturnsOnCall[len(fake.autoscalingV2ArgsForCall)]
	fake.autoscalingV2ArgsForCall = append(fake.autoscalingV2ArgsForCall, struct {
	}{})
	stub := fake.AutoscalingV2Stub
	fakeReturns := fake.autoscalingV2Returns
	fake.recordInvocation("AutoscalingV2", []interface{}{})
	fake.autoscalingV2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AutoscalingV2CallCount() int {
	fake.autoscalingV2Mutex.RLock()
	defer fake.autoscalingV2Mutex.RUnlock()
	return len(fake.autoscalingV2ArgsForCall)
}

func (fake *FakeInterface) AutoscalingV2Calls(stub func() v2.AutoscalingV2Interface) {
	fake.autoscalingV2Mutex.Lock()
	defer fake.autoscalingV2Mutex.Unlock()
	fake.AutoscalingV2Stub = stub
}

func (fake *FakeInterface) AutoscalingV2Returns(result1 v2.AutoscalingV2Interface) {
	fake.autoscalingV2Mutex.Lock()
	defer fake.autoscalingV2Mutex.Unlock()
	fake.AutoscalingV2Stub = nil
	fake.autoscalingV2Returns = struct {
		result1 v2.AutoscalingV2Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2ReturnsOnCall(i int, result1 v2.AutoscalingV2Interface) {
	fake.autoscalingV2Mutex.Lock()
	defer fake.autoscalingV2Mutex.Unlock()
	fake.AutoscalingV2Stub = nil
	if fake.autoscalingV2ReturnsOnCall == nil {
		fake.autoscalingV2ReturnsOnCall = make(map[int]struct {
			result1 v2.AutoscalingV2Interface
		})
	}
	fake.autoscalingV2ReturnsOnCall[i] = struct {
		result1 v2.AutoscalingV2Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2beta1() v2beta1.AutoscalingV2beta1Interface {
	fake.autoscalingV2beta1Mutex.Lock()
	ret, specificReturn := fake.autoscalingV2beta1ReturnsOnCall[len(fake.autoscalingV2beta1ArgsForCall)]
	fake.autoscalingV2beta1ArgsForCall = append(fake.autoscalingV2beta1ArgsForCall, struct {
	}{})
	stub := fake.AutoscalingV2beta1Stub
	fakeReturns := fake.autoscalingV2beta1Returns
	fake.recordInvocation("AutoscalingV2beta1", []interface{}{})
	fake.autoscalingV2beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AutoscalingV2beta1CallCount() int {
	fake.autoscalingV2beta1Mutex.RLock()
	defer fake.autoscalingV2beta1Mutex.RUnlock()
	return len(fake.autoscalingV2beta1ArgsForCall)
}

func (fake *FakeInterface) AutoscalingV2beta1Calls(stub func() v2beta1.AutoscalingV2beta1Interface) {
	fake.autoscalingV2beta1Mutex.Lock()
	defer fake.autoscalingV2beta1Mutex.Unlock()
	fake.AutoscalingV2beta1Stub = stub
}

func (fake *FakeInterface) AutoscalingV2beta1Returns(result1 v2beta1.AutoscalingV2beta1Interface) {
	fake.autoscalingV2beta1Mutex.Lock()
	defer fake.autoscalingV2beta1Mutex.Unlock()
	fake.AutoscalingV2beta1Stub = nil
	fake.autoscalingV2beta1Returns = struct {
		result1 v2beta1.AutoscalingV2beta1Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2beta1ReturnsOnCall(i int, result1 v2beta1.AutoscalingV2beta1Interface) {
	fake.autoscalingV2beta1Mutex.Lock()
	defer fake.autoscalingV2beta1Mutex.Unlock()
	fake.AutoscalingV2beta1Stub = nil
	if fake.autoscalingV2beta1ReturnsOnCall == nil {
		fake.autoscalingV2beta1ReturnsOnCall = make(map[int]struct {
			result1 v2beta1.AutoscalingV2beta1Interface
		})
	}
	fake.autoscalingV2beta1ReturnsOnCall[i] = struct {
		result1 v2beta1.AutoscalingV2beta1Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2beta2() v2beta2.AutoscalingV2beta2Interface {
	fake.autoscalingV2beta2Mutex.Lock()
	ret, specificReturn := fake.autoscalingV2beta2ReturnsOnCall[len(fake.autoscalingV2beta2ArgsForCall)]
	fake.autoscalingV2beta2ArgsForCall = append(fake.autoscalingV2beta2ArgsForCall, struct {
	}{})
	stub := fake.AutoscalingV2beta2Stub
	fakeReturns := fake.autoscalingV2beta2Returns
	fake.recordInvocation("AutoscalingV2beta2", []interface{}{})
	fake.autoscalingV2beta2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) AutoscalingV2beta2CallCount() int {
	fake.autoscalingV2beta2Mutex.RLock()
	defer fake.autoscalingV2beta2Mutex.RUnlock()
	return len(fake.autoscalingV2beta2ArgsForCall)
}

func (fake *FakeInterface) AutoscalingV2beta2Calls(stub func() v2beta2.AutoscalingV2beta2Interface) {
	fake.autoscalingV2beta2Mutex.Lock()
	defer fake.autoscalingV2beta2Mutex.Unlock()
	fake.AutoscalingV2beta2Stub = stub
}

func (fake *FakeInterface) AutoscalingV2beta2Returns(result1 v2beta2.AutoscalingV2beta2Interface) {
	fake.autoscalingV2beta2Mutex.Lock()
	defer fake.autoscalingV2beta2Mutex.Unlock()
	fake.AutoscalingV2beta2Stub = nil
	fake.autoscalingV2beta2Returns = struct {
		result1 v2beta2.AutoscalingV2beta2Interface
	}{result1}
}

func (fake *FakeInterface) AutoscalingV2beta2ReturnsOnCall(i int, result1 v2beta2.AutoscalingV2beta2Interface) {
	fake.autoscalingV2beta2Mutex.Lock()
	defer fake.autoscalingV2beta2Mutex.Unlock()
	fake.AutoscalingV2beta2Stub = nil
	if fake.autoscalingV2beta2ReturnsOnCall == nil {
		fake.autoscalingV2beta2ReturnsOnCall = make(map[int]struct {
			result1 v2beta2.AutoscalingV2beta2Interface
		})
	}
	fake.autoscalingV2beta2ReturnsOnCall[i] = struct {
		result1 v2beta2.AutoscalingV2beta2Interface
	}{result1}
}

func (fake *FakeInterface) BatchV1() v1e.BatchV1Interface {
	fake.batchV1Mutex.Lock()
	ret, specificReturn := fake.batchV1ReturnsOnCall[len(fake.batchV1ArgsForCall)]
	fake.batchV1ArgsForCall = append(fake.batchV1ArgsForCall, struct {
	}{})
	stub := fake.BatchV1Stub
	fakeReturns := fake.batchV1Returns
	fake.recordInvocation("BatchV1", []interface{}{})
	fake.batchV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) BatchV1CallCount() int {
	fake.batchV1Mutex.RLock()
	defer fake.batchV1Mutex.RUnlock()
	return len(fake.batchV1ArgsForCall)
}

func (fake *FakeInterface) BatchV1Calls(stub func() v1e.BatchV1Interface) {
	fake.batchV1Mutex.Lock()
	defer fake.batchV1Mutex.Unlock()
	fake.BatchV1Stub = stub
}

func (fake *FakeInterface) BatchV1Returns(result1 v1e.BatchV1Interface) {
	fake.batchV1Mutex.Lock()
	defer fake.batchV1Mutex.Unlock()
	fake.BatchV1Stub = nil
	fake.batchV1Returns = struct {
		result1 v1e.BatchV1Interface
	}{result1}
}

func (fake *FakeInterface) BatchV1ReturnsOnCall(i int, result1 v1e.BatchV1Interface) {
	fake.batchV1Mutex.Lock()
	defer fake.batchV1Mutex.Unlock()
	fake.BatchV1Stub = nil
	if fake.batchV1ReturnsOnCall == nil {
		fake.batchV1ReturnsOnCall = make(map[int]struct {
			result1 v1e.BatchV1Interface
		})
	}
	fake.batchV1ReturnsOnCall[i] = struct {
		result1 v1e.BatchV1Interface
	}{result1}
}

func (fake *FakeInterface) BatchV1beta1() v1beta1d.BatchV1beta1Interface {
	fake.batchV1beta1Mutex.Lock()
	ret, specificReturn := fake.batchV1beta1ReturnsOnCall[len(fake.batchV1beta1ArgsForCall)]
	fake.batchV1beta1ArgsForCall = append(fake.batchV1beta1ArgsForCall, struct {
	}{})
	stub := fake.BatchV1beta1Stub
	fakeReturns := fake.batchV1beta1Returns
	fake.recordInvocation("BatchV1beta1", []interface{}{})
	fake.batchV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) BatchV1beta1CallCount() int {
	fake.batchV1beta1Mutex.RLock()
	defer fake.batchV1beta1Mutex.RUnlock()
	return len(fake.batchV1beta1ArgsForCall)
}

func (fake *FakeInterface) BatchV1beta1Calls(stub func() v1beta1d.BatchV1beta1Interface) {
	fake.batchV1beta1Mutex.Lock()
	defer fake.batchV1beta1Mutex.Unlock()
	fake.BatchV1beta1Stub = stub
}

func (fake *FakeInterface) BatchV1beta1Returns(result1 v1beta1d.BatchV1beta1Interface) {
	fake.batchV1beta1Mutex.Lock()
	defer fake.batchV1beta1Mutex.Unlock()
	fake.BatchV1beta1Stub = nil
	fake.batchV1beta1Returns = struct {
		result1 v1beta1d.BatchV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) BatchV1beta1ReturnsOnCall(i int, result1 v1beta1d.BatchV1beta1Interface) {
	fake.batchV1beta1Mutex.Lock()
	defer fake.batchV1beta1Mutex.Unlock()
	fake.BatchV1beta1Stub = nil
	if fake.batchV1beta1ReturnsOnCall == nil {
		fake.batchV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1d.BatchV1beta1Interface
		})
	}
	fake.batchV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1d.BatchV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) CertificatesV1() v1f.CertificatesV1Interface {
	fake.certificatesV1Mutex.Lock()
	ret, specificReturn := fake.certificatesV1ReturnsOnCall[len(fake.certificatesV1ArgsForCall)]
	fake.certificatesV1ArgsForCall = append(fake.certificatesV1ArgsForCall, struct {
	}{})
	stub := fake.CertificatesV1Stub
	fakeReturns := fake.certificatesV1Returns
	fake.recordInvocation("CertificatesV1", []interface{}{})
	fake.certificatesV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) CertificatesV1CallCount() int {
	fake.certificatesV1Mutex.RLock()
	defer fake.certificatesV1Mutex.RUnlock()
	return len(fake.certificatesV1ArgsForCall)
}

func (fake *FakeInterface) CertificatesV1Calls(stub func() v1f.CertificatesV1Interface) {
	fake.certificatesV1Mutex.Lock()
	defer fake.certificatesV1Mutex.Unlock()
	fake.CertificatesV1Stub = stub
}

func (fake *FakeInterface) CertificatesV1Returns(result1 v1f.CertificatesV1Interface) {
	fake.certificatesV1Mutex.Lock()
	defer fake.certificatesV1Mutex.Unlock()
	fake.CertificatesV1Stub = nil
	fake.certificatesV1Returns = struct {
		result1 v1f.CertificatesV1Interface
	}{result1}
}

func (fake *FakeInterface) CertificatesV1ReturnsOnCall(i int, result1 v1f.CertificatesV1Interface) {
	fake.certificatesV1Mutex.Lock()
	defer fake.certificatesV1Mutex.Unlock()
	fake.CertificatesV1Stub = nil
	if fake.certificatesV1ReturnsOnCall == nil {
		fake.certificatesV1ReturnsOnCall = make(map[int]struct {
			result1 v1f.CertificatesV1Interface
		})
	}
	fake.certificatesV1ReturnsOnCall[i] = struct {
		result1 v1f.CertificatesV1Interface
	}{result1}
}

func (fake *FakeInterface) CertificatesV1beta1() v1beta1e.CertificatesV1beta1Interface {
	fake.certificatesV1beta1Mutex.Lock()
	ret, specificReturn := fake.certificatesV1beta1ReturnsOnCall[len(fake.certificatesV1beta1ArgsForCall)]
	fake.certificatesV1beta1ArgsForCall = append(fake.certificatesV1beta1ArgsForCall, struct {
	}{})
	stub := fake.CertificatesV1beta1Stub
	fakeReturns := fake.certificatesV1beta1Returns
	fake.recordInvocation("CertificatesV1beta1", []interface{}{})
	fake.certificatesV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) CertificatesV1beta1CallCount() int {
	fake.certificatesV1beta1Mutex.RLock()
	defer fake.certificatesV1beta1Mutex.RUnlock()
	return len(fake.certificatesV1beta1ArgsForCall)
}

func (fake *FakeInterface) CertificatesV1beta1Calls(stub func() v1beta1e.CertificatesV1beta1Interface) {
	fake.certificatesV1beta1Mutex.Lock()
	defer fake.certificatesV1beta1Mutex.Unlock()
	fake.CertificatesV1beta1Stub = stub
}

func (fake *FakeInterface) CertificatesV1beta1Returns(result1 v1beta1e.CertificatesV1beta1Interface) {
	fake.certificatesV1beta1Mutex.Lock()
	defer fake.certificatesV1beta1Mutex.Unlock()
	fake.CertificatesV1beta1Stub = nil
	fake.certificatesV1beta1Returns = struct {
		result1 v1beta1e.CertificatesV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) CertificatesV1beta1ReturnsOnCall(i int, result1 v1beta1e.CertificatesV1beta1Interface) {
	fake.certificatesV1beta1Mutex.Lock()
	defer fake.certificatesV1beta1Mutex.Unlock()
	fake.CertificatesV1beta1Stub = nil
	if fake.certificatesV1beta1ReturnsOnCall == nil {
		fake.certificatesV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1e.CertificatesV1beta1Interface
		})
	}
	fake.certificatesV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1e.CertificatesV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) CoordinationV1() v1g.CoordinationV1Interface {
	fake.coordinationV1Mutex.Lock()
	ret, specificReturn := fake.coordinationV1ReturnsOnCall[len(fake.coordinationV1ArgsForCall)]
	fake.coordinationV1ArgsForCall = append(fake.coordinationV1ArgsForCall, struct {
	}{})
	stub := fake.CoordinationV1Stub
	fakeReturns := fake.coordinationV1Returns
	fake.recordInvocation("CoordinationV1", []interface{}{})
	fake.coordinationV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) CoordinationV1CallCount() int {
	fake.coordinationV1Mutex.RLock()
	defer fake.coordinationV1Mutex.RUnlock()
	return len(fake.coordinationV1ArgsForCall)
}

func (fake *FakeInterface) CoordinationV1Calls(stub func() v1g.CoordinationV1Interface) {
	fake.coordinationV1Mutex.Lock()
	defer fake.coordinationV1Mutex.Unlock()
	fake.CoordinationV1Stub = stub
}

func (fake *FakeInterface) CoordinationV1Returns(result1 v1g.CoordinationV1Interface) {
	fake.coordinationV1Mutex.Lock()
	defer fake.coordinationV1Mutex.Unlock()
	fake.CoordinationV1Stub = nil
	fake.coordinationV1Returns = struct {
		result1 v1g.CoordinationV1Interface
	}{result1}
}

func (fake *FakeInterface) CoordinationV1ReturnsOnCall(i int, result1 v1g.CoordinationV1Interface) {
	fake.coordinationV1Mutex.Lock()
	defer fake.coordinationV1Mutex.Unlock()
	fake.CoordinationV1Stub = nil
	if fake.coordinationV1ReturnsOnCall == nil {
		fake.coordinationV1ReturnsOnCall = make(map[int]struct {
			result1 v1g.CoordinationV1Interface
		})
	}
	fake.coordinationV1ReturnsOnCall[i] = struct {
		result1 v1g.CoordinationV1Interface
	}{result1}
}

func (fake *FakeInterface) CoordinationV1beta1() v1beta1f.CoordinationV1beta1Interface {
	fake.coordinationV1beta1Mutex.Lock()
	ret, specificReturn := fake.coordinationV1beta1ReturnsOnCall[len(fake.coordinationV1beta1ArgsForCall)]
	fake.coordinationV1beta1ArgsForCall = append(fake.coordinationV1beta1ArgsForCall, struct {
	}{})
	stub := fake.CoordinationV1beta1Stub
	fakeReturns := fake.coordinationV1beta1Returns
	fake.recordInvocation("CoordinationV1beta1", []interface{}{})
	fake.coordinationV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) CoordinationV1beta1CallCount() int {
	fake.coordinationV1beta1Mutex.RLock()
	defer fake.coordinationV1beta1Mutex.RUnlock()
	return len(fake.coordinationV1beta1ArgsForCall)
}

func (fake *FakeInterface) CoordinationV1beta1Calls(stub func() v1beta1f.CoordinationV1beta1Interface) {
	fake.coordinationV1beta1Mutex.Lock()
	defer fake.coordinationV1beta1Mutex.Unlock()
	fake.CoordinationV1beta1Stub = stub
}

func (fake *FakeInterface) CoordinationV1beta1Returns(result1 v1beta1f.CoordinationV1beta1Interface) {
	fake.coordinationV1beta1Mutex.Lock()
	defer fake.coordinationV1beta1Mutex.Unlock()
	fake.CoordinationV1beta1Stub = nil
	fake.coordinationV1beta1Returns = struct {
		result1 v1beta1f.CoordinationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) CoordinationV1beta1ReturnsOnCall(i int, result1 v1beta1f.CoordinationV1beta1Interface) {
	fake.coordinationV1beta1Mutex.Lock()
	defer fake.coordinationV1beta1Mutex.Unlock()
	fake.CoordinationV1beta1Stub = nil
	if fake.coordinationV1beta1ReturnsOnCall == nil {
		fake.coordinationV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1f.CoordinationV1beta1Interface
		})
	}
	fake.coordinationV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1f.CoordinationV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) CoreV1() v1h.CoreV1Interface {
	fake.coreV1Mutex.Lock()
	ret, specificReturn := fake.coreV1ReturnsOnCall[len(fake.coreV1ArgsForCall)]
	fake.coreV1ArgsForCall = append(fake.coreV1ArgsForCall, struct {
	}{})
	stub := fake.CoreV1Stub
	fakeReturns := fake.coreV1Returns
	fake.recordInvocation("CoreV1", []interface{}{})
	fake.coreV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) CoreV1CallCount() int {
	fake.coreV1Mutex.RLock()
	defer fake.coreV1Mutex.RUnlock()
	return len(fake.coreV1ArgsForCall)
}

func (fake *FakeInterface) CoreV1Calls(stub func() v1h.CoreV1Interface) {
	fake.coreV1Mutex.Lock()
	defer fake.coreV1Mutex.Unlock()
	fake.CoreV1Stub = stub
}

func (fake *FakeInterface) CoreV1Returns(result1 v1h.CoreV1Interface) {
	fake.coreV1Mutex.Lock()
	defer fake.coreV1Mutex.Unlock()
	fake.CoreV1Stub = nil
	fake.coreV1Returns = struct {
		result1 v1h.CoreV1Interface
	}{result1}
}

func (fake *FakeInterface) CoreV1ReturnsOnCall(i int, result1 v1h.CoreV1Interface) {
	fake.coreV1Mutex.Lock()
	defer fake.coreV1Mutex.Unlock()
	fake.CoreV1Stub = nil
	if fake.coreV1ReturnsOnCall == nil {
		fake.coreV1ReturnsOnCall = make(map[int]struct {
			result1 v1h.CoreV1Interface
		})
	}
	fake.coreV1ReturnsOnCall[i] = struct {
		result1 v1h.CoreV1Interface
	}{result1}
}

func (fake *FakeInterface) Discovery() discovery.DiscoveryInterface {
	fake.discoveryMutex.Lock()
	ret, specificReturn := fake.discoveryReturnsOnCall[len(fake.discoveryArgsForCall)]
	fake.discoveryArgsForCall = append(fake.discoveryArgsForCall, struct {
	}{})
	stub := fake.DiscoveryStub
	fakeReturns := fake.discoveryReturns
	fake.recordInvocation("Discovery", []interface{}{})
	fake.discoveryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) DiscoveryCallCount() int {
	fake.discoveryMutex.RLock()
	defer fake.discoveryMutex.RUnlock()
	return len(fake.discoveryArgsForCall)
}

func (fake *FakeInterface) DiscoveryCalls(stub func() discovery.DiscoveryInterface) {
	fake.discoveryMutex.Lock()
	defer fake.discoveryMutex.Unlock()
	fake.DiscoveryStub = stub
}

func (fake *FakeInterface) DiscoveryReturns(result1 discovery.DiscoveryInterface) {
	fake.discoveryMutex.Lock()
	defer fake.discoveryMutex.Unlock()
	fake.DiscoveryStub = nil
	fake.discoveryReturns = struct {
		result1 discovery.DiscoveryInterface
	}{result1}
}

func (fake *FakeInterface) DiscoveryReturnsOnCall(i int, result1 discovery.DiscoveryInterface) {
	fake.discoveryMutex.Lock()
	defer fake.discoveryMutex.Unlock()
	fake.DiscoveryStub = nil
	if fake.discoveryReturnsOnCall == nil {
		fake.discoveryReturnsOnCall = make(map[int]struct {
			result1 discovery.DiscoveryInterface
		})
	}
	fake.discoveryReturnsOnCall[i] = struct {
		result1 discovery.DiscoveryInterface
	}{result1}
}

func (fake *FakeInterface) DiscoveryV1() v1i.DiscoveryV1Interface {
	fake.discoveryV1Mutex.Lock()
	ret, specificReturn := fake.discoveryV1ReturnsOnCall[len(fake.discoveryV1ArgsForCall)]
	fake.discoveryV1ArgsForCall = append(fake.discoveryV1ArgsForCall, struct {
	}{})
	stub := fake.DiscoveryV1Stub
	fakeReturns := fake.discoveryV1Returns
	fake.recordInvocation("DiscoveryV1", []interface{}{})
	fake.discoveryV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) DiscoveryV1CallCount() int {
	fake.discoveryV1Mutex.RLock()
	defer fake.discoveryV1Mutex.RUnlock()
	return len(fake.discoveryV1ArgsForCall)
}

func (fake *FakeInterface) DiscoveryV1Calls(stub func() v1i.DiscoveryV1Interface) {
	fake.discoveryV1Mutex.Lock()
	defer fake.discoveryV1Mutex.Unlock()
	fake.DiscoveryV1Stub = stub
}

func (fake *FakeInterface) DiscoveryV1Returns(result1 v1i.DiscoveryV1Interface) {
	fake.discoveryV1Mutex.Lock()
	defer fake.discoveryV1Mutex.Unlock()
	fake.DiscoveryV1Stub = nil
	fake.discoveryV1Returns = struct {
		result1 v1i.DiscoveryV1Interface
	}{result1}
}

func (fake *FakeInterface) DiscoveryV1ReturnsOnCall(i int, result1 v1i.DiscoveryV1Interface) {
	fake.discoveryV1Mutex.Lock()
	defer fake.discoveryV1Mutex.Unlock()
	fake.DiscoveryV1Stub = nil
	if fake.discoveryV1ReturnsOnCall == nil {
		fake.discoveryV1ReturnsOnCall = make(map[int]struct {
			result1 v1i.DiscoveryV1Interface
		})
	}
	fake.discoveryV1ReturnsOnCall[i] = struct {
		result1 v1i.DiscoveryV1Interface
	}{result1}
}

func (fake *FakeInterface) DiscoveryV1beta1() v1beta1g.DiscoveryV1beta1Interface {
	fake.discoveryV1beta1Mutex.Lock()
	ret, specificReturn := fake.discoveryV1beta1ReturnsOnCall[len(fake.discoveryV1beta1ArgsForCall)]
	fake.discoveryV1beta1ArgsForCall = append(fake.discoveryV1beta1ArgsForCall, struct {
	}{})
	stub := fake.DiscoveryV1beta1Stub
	fakeReturns := fake.discoveryV1beta1Returns
	fake.recordInvocation("DiscoveryV1beta1", []interface{}{})
	fake.discoveryV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) DiscoveryV1beta1CallCount() int {
	fake.discoveryV1beta1Mutex.RLock()
	defer fake.discoveryV1beta1Mutex.RUnlock()
	return len(fake.discoveryV1beta1ArgsForCall)
}

func (fake *FakeInterface) DiscoveryV1beta1Calls(stub func() v1beta1g.DiscoveryV1beta1Interface) {
	fake.discoveryV1beta1Mutex.Lock()
	defer fake.discoveryV1beta1Mutex.Unlock()
	fake.DiscoveryV1beta1Stub = stub
}

func (fake *FakeInterface) DiscoveryV1beta1Returns(result1 v1beta1g.DiscoveryV1beta1Interface) {
	fake.discoveryV1beta1Mutex.Lock()
	defer fake.discoveryV1beta1Mutex.Unlock()
	fake.DiscoveryV1beta1Stub = nil
	fake.discoveryV1beta1Returns = struct {
		result1 v1beta1g.DiscoveryV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) DiscoveryV1beta1ReturnsOnCall(i int, result1 v1beta1g.DiscoveryV1beta1Interface) {
	fake.discoveryV1beta1Mutex.Lock()
	defer fake.discoveryV1beta1Mutex.Unlock()
	fake.DiscoveryV1beta1Stub = nil
	if fake.discoveryV1beta1ReturnsOnCall == nil {
		fake.discoveryV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1g.DiscoveryV1beta1Interface
		})
	}
	fake.discoveryV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1g.DiscoveryV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) EventsV1() v1j.EventsV1Interface {
	fake.eventsV1Mutex.Lock()
	ret, specificReturn := fake.eventsV1ReturnsOnCall[len(fake.eventsV1ArgsForCall)]
	fake.eventsV1ArgsForCall = append(fake.eventsV1ArgsForCall, struct {
	}{})
	stub := fake.EventsV1Stub
	fakeReturns := fake.eventsV1Returns
	fake.recordInvocation("EventsV1", []interface{}{})
	fake.eventsV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) EventsV1CallCount() int {
	fake.eventsV1Mutex.RLock()
	defer fake.eventsV1Mutex.RUnlock()
	return len(fake.eventsV1ArgsForCall)
}

func (fake *FakeInterface) EventsV1Calls(stub func() v1j.EventsV1Interface) {
	fake.eventsV1Mutex.Lock()
	defer fake.eventsV1Mutex.Unlock()
	fake.EventsV1Stub = stub
}

func (fake *FakeInterface) EventsV1Returns(result1 v1j.EventsV1Interface) {
	fake.eventsV1Mutex.Lock()
	defer fake.eventsV1Mutex.Unlock()
	fake.EventsV1Stub = nil
	fake.eventsV1Returns = struct {
		result1 v1j.EventsV1Interface
	}{result1}
}

func (fake *FakeInterface) EventsV1ReturnsOnCall(i int, result1 v1j.EventsV1Interface) {
	fake.eventsV1Mutex.Lock()
	defer fake.eventsV1Mutex.Unlock()
	fake.EventsV1Stub = nil
	if fake.eventsV1ReturnsOnCall == nil {
		fake.eventsV1ReturnsOnCall = make(map[int]struct {
			result1 v1j.EventsV1Interface
		})
	}
	fake.eventsV1ReturnsOnCall[i] = struct {
		result1 v1j.EventsV1Interface
	}{result1}
}

func (fake *FakeInterface) EventsV1beta1() v1beta1h.EventsV1beta1Interface {
	fake.eventsV1beta1Mutex.Lock()
	ret, specificReturn := fake.eventsV1beta1ReturnsOnCall[len(fake.eventsV1beta1ArgsForCall)]
	fake.eventsV1beta1ArgsForCall = append(fake.eventsV1beta1ArgsForCall, struct {
	}{})
	stub := fake.EventsV1beta1Stub
	fakeReturns := fake.eventsV1beta1Returns
	fake.recordInvocation("EventsV1beta1", []interface{}{})
	fake.eventsV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) EventsV1beta1CallCount() int {
	fake.eventsV1beta1Mutex.RLock()
	defer fake.eventsV1beta1Mutex.RUnlock()
	return len(fake.eventsV1beta1ArgsForCall)
}

func (fake *FakeInterface) EventsV1beta1Calls(stub func() v1beta1h.EventsV1beta1Interface) {
	fake.eventsV1beta1Mutex.Lock()
	defer fake.eventsV1beta1Mutex.Unlock()
	fake.EventsV1beta1Stub = stub
}

func (fake *FakeInterface) EventsV1beta1Returns(result1 v1beta1h.EventsV1beta1Interface) {
	fake.eventsV1beta1Mutex.Lock()
	defer fake.eventsV1beta1Mutex.Unlock()
	fake.EventsV1beta1Stub = nil
	fake.eventsV1beta1Returns = struct {
		result1 v1beta1h.EventsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) EventsV1beta1ReturnsOnCall(i int, result1 v1beta1h.EventsV1beta1Interface) {
	fake.eventsV1beta1Mutex.Lock()
	defer fake.eventsV1beta1Mutex.Unlock()
	fake.EventsV1beta1Stub = nil
	if fake.eventsV1beta1ReturnsOnCall == nil {
		fake.eventsV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1h.EventsV1beta1Interface
		})
	}
	fake.eventsV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1h.EventsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) ExtensionsV1beta1() v1beta1i.ExtensionsV1beta1Interface {
	fake.extensionsV1beta1Mutex.Lock()
	ret, specificReturn := fake.extensionsV1beta1ReturnsOnCall[len(fake.extensionsV1beta1ArgsForCall)]
	fake.extensionsV1beta1ArgsForCall = append(fake.extensionsV1beta1ArgsForCall, struct {
	}{})
	stub := fake.ExtensionsV1beta1Stub
	fakeReturns := fake.extensionsV1beta1Returns
	fake.recordInvocation("ExtensionsV1beta1", []interface{}{})
	fake.extensionsV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) ExtensionsV1beta1CallCount() int {
	fake.extensionsV1beta1Mutex.RLock()
	defer fake.extensionsV1beta1Mutex.RUnlock()
	return len(fake.extensionsV1beta1ArgsForCall)
}

func (fake *FakeInterface) ExtensionsV1beta1Calls(stub func() v1beta1i.ExtensionsV1beta1Interface) {
	fake.extensionsV1beta1Mutex.Lock()
	defer fake.extensionsV1beta1Mutex.Unlock()
	fake.ExtensionsV1beta1Stub = stub
}

func (fake *FakeInterface) ExtensionsV1beta1Returns(result1 v1beta1i.ExtensionsV1beta1Interface) {
	fake.extensionsV1beta1Mutex.Lock()
	defer fake.extensionsV1beta1Mutex.Unlock()
	fake.ExtensionsV1beta1Stub = nil
	fake.extensionsV1beta1Returns = struct {
		result1 v1beta1i.ExtensionsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) ExtensionsV1beta1ReturnsOnCall(i int, result1 v1beta1i.ExtensionsV1beta1Interface) {
	fake.extensionsV1beta1Mutex.Lock()
	defer fake.extensionsV1beta1Mutex.Unlock()
	fake.ExtensionsV1beta1Stub = nil
	if fake.extensionsV1beta1ReturnsOnCall == nil {
		fake.extensionsV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1i.ExtensionsV1beta1Interface
		})
	}
	fake.extensionsV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1i.ExtensionsV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1alpha1() v1alpha1.FlowcontrolV1alpha1Interface {
	fake.flowcontrolV1alpha1Mutex.Lock()
	ret, specificReturn := fake.flowcontrolV1alpha1ReturnsOnCall[len(fake.flowcontrolV1alpha1ArgsForCall)]
	fake.flowcontrolV1alpha1ArgsForCall = append(fake.flowcontrolV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.FlowcontrolV1alpha1Stub
	fakeReturns := fake.flowcontrolV1alpha1Returns
	fake.recordInvocation("FlowcontrolV1alpha1", []interface{}{})
	fake.flowcontrolV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) FlowcontrolV1alpha1CallCount() int {
	fake.flowcontrolV1alpha1Mutex.RLock()
	defer fake.flowcontrolV1alpha1Mutex.RUnlock()
	return len(fake.flowcontrolV1alpha1ArgsForCall)
}

func (fake *FakeInterface) FlowcontrolV1alpha1Calls(stub func() v1alpha1.FlowcontrolV1alpha1Interface) {
	fake.flowcontrolV1alpha1Mutex.Lock()
	defer fake.flowcontrolV1alpha1Mutex.Unlock()
	fake.FlowcontrolV1alpha1Stub = stub
}

func (fake *FakeInterface) FlowcontrolV1alpha1Returns(result1 v1alpha1.FlowcontrolV1alpha1Interface) {
	fake.flowcontrolV1alpha1Mutex.Lock()
	defer fake.flowcontrolV1alpha1Mutex.Unlock()
	fake.FlowcontrolV1alpha1Stub = nil
	fake.flowcontrolV1alpha1Returns = struct {
		result1 v1alpha1.FlowcontrolV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1alpha1ReturnsOnCall(i int, result1 v1alpha1.FlowcontrolV1alpha1Interface) {
	fake.flowcontrolV1alpha1Mutex.Lock()
	defer fake.flowcontrolV1alpha1Mutex.Unlock()
	fake.FlowcontrolV1alpha1Stub = nil
	if fake.flowcontrolV1alpha1ReturnsOnCall == nil {
		fake.flowcontrolV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1.FlowcontrolV1alpha1Interface
		})
	}
	fake.flowcontrolV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1.FlowcontrolV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1beta1() v1beta1j.FlowcontrolV1beta1Interface {
	fake.flowcontrolV1beta1Mutex.Lock()
	ret, specificReturn := fake.flowcontrolV1beta1ReturnsOnCall[len(fake.flowcontrolV1beta1ArgsForCall)]
	fake.flowcontrolV1beta1ArgsForCall = append(fake.flowcontrolV1beta1ArgsForCall, struct {
	}{})
	stub := fake.FlowcontrolV1beta1Stub
	fakeReturns := fake.flowcontrolV1beta1Returns
	fake.recordInvocation("FlowcontrolV1beta1", []interface{}{})
	fake.flowcontrolV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) FlowcontrolV1beta1CallCount() int {
	fake.flowcontrolV1beta1Mutex.RLock()
	defer fake.flowcontrolV1beta1Mutex.RUnlock()
	return len(fake.flowcontrolV1beta1ArgsForCall)
}

func (fake *FakeInterface) FlowcontrolV1beta1Calls(stub func() v1beta1j.FlowcontrolV1beta1Interface) {
	fake.flowcontrolV1beta1Mutex.Lock()
	defer fake.flowcontrolV1beta1Mutex.Unlock()
	fake.FlowcontrolV1beta1Stub = stub
}

func (fake *FakeInterface) FlowcontrolV1beta1Returns(result1 v1beta1j.FlowcontrolV1beta1Interface) {
	fake.flowcontrolV1beta1Mutex.Lock()
	defer fake.flowcontrolV1beta1Mutex.Unlock()
	fake.FlowcontrolV1beta1Stub = nil
	fake.flowcontrolV1beta1Returns = struct {
		result1 v1beta1j.FlowcontrolV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1beta1ReturnsOnCall(i int, result1 v1beta1j.FlowcontrolV1beta1Interface) {
	fake.flowcontrolV1beta1Mutex.Lock()
	defer fake.flowcontrolV1beta1Mutex.Unlock()
	fake.FlowcontrolV1beta1Stub = nil
	if fake.flowcontrolV1beta1ReturnsOnCall == nil {
		fake.flowcontrolV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1j.FlowcontrolV1beta1Interface
		})
	}
	fake.flowcontrolV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1j.FlowcontrolV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1beta2() v1beta2a.FlowcontrolV1beta2Interface {
	fake.flowcontrolV1beta2Mutex.Lock()
	ret, specificReturn := fake.flowcontrolV1beta2ReturnsOnCall[len(fake.flowcontrolV1beta2ArgsForCall)]
	fake.flowcontrolV1beta2ArgsForCall = append(fake.flowcontrolV1beta2ArgsForCall, struct {
	}{})
	stub := fake.FlowcontrolV1beta2Stub
	fakeReturns := fake.flowcontrolV1beta2Returns
	fake.recordInvocation("FlowcontrolV1beta2", []interface{}{})
	fake.flowcontrolV1beta2Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) FlowcontrolV1beta2CallCount() int {
	fake.flowcontrolV1beta2Mutex.RLock()
	defer fake.flowcontrolV1beta2Mutex.RUnlock()
	return len(fake.flowcontrolV1beta2ArgsForCall)
}

func (fake *FakeInterface) FlowcontrolV1beta2Calls(stub func() v1beta2a.FlowcontrolV1beta2Interface) {
	fake.flowcontrolV1beta2Mutex.Lock()
	defer fake.flowcontrolV1beta2Mutex.Unlock()
	fake.FlowcontrolV1beta2Stub = stub
}

func (fake *FakeInterface) FlowcontrolV1beta2Returns(result1 v1beta2a.FlowcontrolV1beta2Interface) {
	fake.flowcontrolV1beta2Mutex.Lock()
	defer fake.flowcontrolV1beta2Mutex.Unlock()
	fake.FlowcontrolV1beta2Stub = nil
	fake.flowcontrolV1beta2Returns = struct {
		result1 v1beta2a.FlowcontrolV1beta2Interface
	}{result1}
}

func (fake *FakeInterface) FlowcontrolV1beta2ReturnsOnCall(i int, result1 v1beta2a.FlowcontrolV1beta2Interface) {
	fake.flowcontrolV1beta2Mutex.Lock()
	defer fake.flowcontrolV1beta2Mutex.Unlock()
	fake.FlowcontrolV1beta2Stub = nil
	if fake.flowcontrolV1beta2ReturnsOnCall == nil {
		fake.flowcontrolV1beta2ReturnsOnCall = make(map[int]struct {
			result1 v1beta2a.FlowcontrolV1beta2Interface
		})
	}
	fake.flowcontrolV1beta2ReturnsOnCall[i] = struct {
		result1 v1beta2a.FlowcontrolV1beta2Interface
	}{result1}
}

func (fake *FakeInterface) InternalV1alpha1() v1alpha1a.InternalV1alpha1Interface {
	fake.internalV1alpha1Mutex.Lock()
	ret, specificReturn := fake.internalV1alpha1ReturnsOnCall[len(fake.internalV1alpha1ArgsForCall)]
	fake.internalV1alpha1ArgsForCall = append(fake.internalV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.InternalV1alpha1Stub
	fakeReturns := fake.internalV1alpha1Returns
	fake.recordInvocation("InternalV1alpha1", []interface{}{})
	fake.internalV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) InternalV1alpha1CallCount() int {
	fake.internalV1alpha1Mutex.RLock()
	defer fake.internalV1alpha1Mutex.RUnlock()
	return len(fake.internalV1alpha1ArgsForCall)
}

func (fake *FakeInterface) InternalV1alpha1Calls(stub func() v1alpha1a.InternalV1alpha1Interface) {
	fake.internalV1alpha1Mutex.Lock()
	defer fake.internalV1alpha1Mutex.Unlock()
	fake.InternalV1alpha1Stub = stub
}

func (fake *FakeInterface) InternalV1alpha1Returns(result1 v1alpha1a.InternalV1alpha1Interface) {
	fake.internalV1alpha1Mutex.Lock()
	defer fake.internalV1alpha1Mutex.Unlock()
	fake.InternalV1alpha1Stub = nil
	fake.internalV1alpha1Returns = struct {
		result1 v1alpha1a.InternalV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) InternalV1alpha1ReturnsOnCall(i int, result1 v1alpha1a.InternalV1alpha1Interface) {
	fake.internalV1alpha1Mutex.Lock()
	defer fake.internalV1alpha1Mutex.Unlock()
	fake.InternalV1alpha1Stub = nil
	if fake.internalV1alpha1ReturnsOnCall == nil {
		fake.internalV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1a.InternalV1alpha1Interface
		})
	}
	fake.internalV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1a.InternalV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1() v1k.NetworkingV1Interface {
	fake.networkingV1Mutex.Lock()
	ret, specificReturn := fake.networkingV1ReturnsOnCall[len(fake.networkingV1ArgsForCall)]
	fake.networkingV1ArgsForCall = append(fake.networkingV1ArgsForCall, struct {
	}{})
	stub := fake.NetworkingV1Stub
	fakeReturns := fake.networkingV1Returns
	fake.recordInvocation("NetworkingV1", []interface{}{})
	fake.networkingV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NetworkingV1CallCount() int {
	fake.networkingV1Mutex.RLock()
	defer fake.networkingV1Mutex.RUnlock()
	return len(fake.networkingV1ArgsForCall)
}

func (fake *FakeInterface) NetworkingV1Calls(stub func() v1k.NetworkingV1Interface) {
	fake.networkingV1Mutex.Lock()
	defer fake.networkingV1Mutex.Unlock()
	fake.NetworkingV1Stub = stub
}

func (fake *FakeInterface) NetworkingV1Returns(result1 v1k.NetworkingV1Interface) {
	fake.networkingV1Mutex.Lock()
	defer fake.networkingV1Mutex.Unlock()
	fake.NetworkingV1Stub = nil
	fake.networkingV1Returns = struct {
		result1 v1k.NetworkingV1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1ReturnsOnCall(i int, result1 v1k.NetworkingV1Interface) {
	fake.networkingV1Mutex.Lock()
	defer fake.networkingV1Mutex.Unlock()
	fake.NetworkingV1Stub = nil
	if fake.networkingV1ReturnsOnCall == nil {
		fake.networkingV1ReturnsOnCall = make(map[int]struct {
			result1 v1k.NetworkingV1Interface
		})
	}
	fake.networkingV1ReturnsOnCall[i] = struct {
		result1 v1k.NetworkingV1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1alpha1() v1alpha1b.NetworkingV1alpha1Interface {
	fake.networkingV1alpha1Mutex.Lock()
	ret, specificReturn := fake.networkingV1alpha1ReturnsOnCall[len(fake.networkingV1alpha1ArgsForCall)]
	fake.networkingV1alpha1ArgsForCall = append(fake.networkingV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.NetworkingV1alpha1Stub
	fakeReturns := fake.networkingV1alpha1Returns
	fake.recordInvocation("NetworkingV1alpha1", []interface{}{})
	fake.networkingV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NetworkingV1alpha1CallCount() int {
	fake.networkingV1alpha1Mutex.RLock()
	defer fake.networkingV1alpha1Mutex.RUnlock()
	return len(fake.networkingV1alpha1ArgsForCall)
}

func (fake *FakeInterface) NetworkingV1alpha1Calls(stub func() v1alpha1b.NetworkingV1alpha1Interface) {
	fake.networkingV1alpha1Mutex.Lock()
	defer fake.networkingV1alpha1Mutex.Unlock()
	fake.NetworkingV1alpha1Stub = stub
}

func (fake *FakeInterface) NetworkingV1alpha1Returns(result1 v1alpha1b.NetworkingV1alpha1Interface) {
	fake.networkingV1alpha1Mutex.Lock()
	defer fake.networkingV1alpha1Mutex.Unlock()
	fake.NetworkingV1alpha1Stub = nil
	fake.networkingV1alpha1Returns = struct {
		result1 v1alpha1b.NetworkingV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1alpha1ReturnsOnCall(i int, result1 v1alpha1b.NetworkingV1alpha1Interface) {
	fake.networkingV1alpha1Mutex.Lock()
	defer fake.networkingV1alpha1Mutex.Unlock()
	fake.NetworkingV1alpha1Stub = nil
	if fake.networkingV1alpha1ReturnsOnCall == nil {
		fake.networkingV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1b.NetworkingV1alpha1Interface
		})
	}
	fake.networkingV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1b.NetworkingV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1beta1() v1beta1k.NetworkingV1beta1Interface {
	fake.networkingV1beta1Mutex.Lock()
	ret, specificReturn := fake.networkingV1beta1ReturnsOnCall[len(fake.networkingV1beta1ArgsForCall)]
	fake.networkingV1beta1ArgsForCall = append(fake.networkingV1beta1ArgsForCall, struct {
	}{})
	stub := fake.NetworkingV1beta1Stub
	fakeReturns := fake.networkingV1beta1Returns
	fake.recordInvocation("NetworkingV1beta1", []interface{}{})
	fake.networkingV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NetworkingV1beta1CallCount() int {
	fake.networkingV1beta1Mutex.RLock()
	defer fake.networkingV1beta1Mutex.RUnlock()
	return len(fake.networkingV1beta1ArgsForCall)
}

func (fake *FakeInterface) NetworkingV1beta1Calls(stub func() v1beta1k.NetworkingV1beta1Interface) {
	fake.networkingV1beta1Mutex.Lock()
	defer fake.networkingV1beta1Mutex.Unlock()
	fake.NetworkingV1beta1Stub = stub
}

func (fake *FakeInterface) NetworkingV1beta1Returns(result1 v1beta1k.NetworkingV1beta1Interface) {
	fake.networkingV1beta1Mutex.Lock()
	defer fake.networkingV1beta1Mutex.Unlock()
	fake.NetworkingV1beta1Stub = nil
	fake.networkingV1beta1Returns = struct {
		result1 v1beta1k.NetworkingV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) NetworkingV1beta1ReturnsOnCall(i int, result1 v1beta1k.NetworkingV1beta1Interface) {
	fake.networkingV1beta1Mutex.Lock()
	defer fake.networkingV1beta1Mutex.Unlock()
	fake.NetworkingV1beta1Stub = nil
	if fake.networkingV1beta1ReturnsOnCall == nil {
		fake.networkingV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1k.NetworkingV1beta1Interface
		})
	}
	fake.networkingV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1k.NetworkingV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1() v1l.NodeV1Interface {
	fake.nodeV1Mutex.Lock()
	ret, specificReturn := fake.nodeV1ReturnsOnCall[len(fake.nodeV1ArgsForCall)]
	fake.nodeV1ArgsForCall = append(fake.nodeV1ArgsForCall, struct {
	}{})
	stub := fake.NodeV1Stub
	fakeReturns := fake.nodeV1Returns
	fake.recordInvocation("NodeV1", []interface{}{})
	fake.nodeV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NodeV1CallCount() int {
	fake.nodeV1Mutex.RLock()
	defer fake.nodeV1Mutex.RUnlock()
	return len(fake.nodeV1ArgsForCall)
}

func (fake *FakeInterface) NodeV1Calls(stub func() v1l.NodeV1Interface) {
	fake.nodeV1Mutex.Lock()
	defer fake.nodeV1Mutex.Unlock()
	fake.NodeV1Stub = stub
}

func (fake *FakeInterface) NodeV1Returns(result1 v1l.NodeV1Interface) {
	fake.nodeV1Mutex.Lock()
	defer fake.nodeV1Mutex.Unlock()
	fake.NodeV1Stub = nil
	fake.nodeV1Returns = struct {
		result1 v1l.NodeV1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1ReturnsOnCall(i int, result1 v1l.NodeV1Interface) {
	fake.nodeV1Mutex.Lock()
	defer fake.nodeV1Mutex.Unlock()
	fake.NodeV1Stub = nil
	if fake.nodeV1ReturnsOnCall == nil {
		fake.nodeV1ReturnsOnCall = make(map[int]struct {
			result1 v1l.NodeV1Interface
		})
	}
	fake.nodeV1ReturnsOnCall[i] = struct {
		result1 v1l.NodeV1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1alpha1() v1alpha1c.NodeV1alpha1Interface {
	fake.nodeV1alpha1Mutex.Lock()
	ret, specificReturn := fake.nodeV1alpha1ReturnsOnCall[len(fake.nodeV1alpha1ArgsForCall)]
	fake.nodeV1alpha1ArgsForCall = append(fake.nodeV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.NodeV1alpha1Stub
	fakeReturns := fake.nodeV1alpha1Returns
	fake.recordInvocation("NodeV1alpha1", []interface{}{})
	fake.nodeV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NodeV1alpha1CallCount() int {
	fake.nodeV1alpha1Mutex.RLock()
	defer fake.nodeV1alpha1Mutex.RUnlock()
	return len(fake.nodeV1alpha1ArgsForCall)
}

func (fake *FakeInterface) NodeV1alpha1Calls(stub func() v1alpha1c.NodeV1alpha1Interface) {
	fake.nodeV1alpha1Mutex.Lock()
	defer fake.nodeV1alpha1Mutex.Unlock()
	fake.NodeV1alpha1Stub = stub
}

func (fake *FakeInterface) NodeV1alpha1Returns(result1 v1alpha1c.NodeV1alpha1Interface) {
	fake.nodeV1alpha1Mutex.Lock()
	defer fake.nodeV1alpha1Mutex.Unlock()
	fake.NodeV1alpha1Stub = nil
	fake.nodeV1alpha1Returns = struct {
		result1 v1alpha1c.NodeV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1alpha1ReturnsOnCall(i int, result1 v1alpha1c.NodeV1alpha1Interface) {
	fake.nodeV1alpha1Mutex.Lock()
	defer fake.nodeV1alpha1Mutex.Unlock()
	fake.NodeV1alpha1Stub = nil
	if fake.nodeV1alpha1ReturnsOnCall == nil {
		fake.nodeV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1c.NodeV1alpha1Interface
		})
	}
	fake.nodeV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1c.NodeV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1beta1() v1beta1l.NodeV1beta1Interface {
	fake.nodeV1beta1Mutex.Lock()
	ret, specificReturn := fake.nodeV1beta1ReturnsOnCall[len(fake.nodeV1beta1ArgsForCall)]
	fake.nodeV1beta1ArgsForCall = append(fake.nodeV1beta1ArgsForCall, struct {
	}{})
	stub := fake.NodeV1beta1Stub
	fakeReturns := fake.nodeV1beta1Returns
	fake.recordInvocation("NodeV1beta1", []interface{}{})
	fake.nodeV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) NodeV1beta1CallCount() int {
	fake.nodeV1beta1Mutex.RLock()
	defer fake.nodeV1beta1Mutex.RUnlock()
	return len(fake.nodeV1beta1ArgsForCall)
}

func (fake *FakeInterface) NodeV1beta1Calls(stub func() v1beta1l.NodeV1beta1Interface) {
	fake.nodeV1beta1Mutex.Lock()
	defer fake.nodeV1beta1Mutex.Unlock()
	fake.NodeV1beta1Stub = stub
}

func (fake *FakeInterface) NodeV1beta1Returns(result1 v1beta1l.NodeV1beta1Interface) {
	fake.nodeV1beta1Mutex.Lock()
	defer fake.nodeV1beta1Mutex.Unlock()
	fake.NodeV1beta1Stub = nil
	fake.nodeV1beta1Returns = struct {
		result1 v1beta1l.NodeV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) NodeV1beta1ReturnsOnCall(i int, result1 v1beta1l.NodeV1beta1Interface) {
	fake.nodeV1beta1Mutex.Lock()
	defer fake.nodeV1beta1Mutex.Unlock()
	fake.NodeV1beta1Stub = nil
	if fake.nodeV1beta1ReturnsOnCall == nil {
		fake.nodeV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1l.NodeV1beta1Interface
		})
	}
	fake.nodeV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1l.NodeV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) PolicyV1() v1m.PolicyV1Interface {
	fake.policyV1Mutex.Lock()
	ret, specificReturn := fake.policyV1ReturnsOnCall[len(fake.policyV1ArgsForCall)]
	fake.policyV1ArgsForCall = append(fake.policyV1ArgsForCall, struct {
	}{})
	stub := fake.PolicyV1Stub
	fakeReturns := fake.policyV1Returns
	fake.recordInvocation("PolicyV1", []interface{}{})
	fake.policyV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) PolicyV1CallCount() int {
	fake.policyV1Mutex.RLock()
	defer fake.policyV1Mutex.RUnlock()
	return len(fake.policyV1ArgsForCall)
}

func (fake *FakeInterface) PolicyV1Calls(stub func() v1m.PolicyV1Interface) {
	fake.policyV1Mutex.Lock()
	defer fake.policyV1Mutex.Unlock()
	fake.PolicyV1Stub = stub
}

func (fake *FakeInterface) PolicyV1Returns(result1 v1m.PolicyV1Interface) {
	fake.policyV1Mutex.Lock()
	defer fake.policyV1Mutex.Unlock()
	fake.PolicyV1Stub = nil
	fake.policyV1Returns = struct {
		result1 v1m.PolicyV1Interface
	}{result1}
}

func (fake *FakeInterface) PolicyV1ReturnsOnCall(i int, result1 v1m.PolicyV1Interface) {
	fake.policyV1Mutex.Lock()
	defer fake.policyV1Mutex.Unlock()
	fake.PolicyV1Stub = nil
	if fake.policyV1ReturnsOnCall == nil {
		fake.policyV1ReturnsOnCall = make(map[int]struct {
			result1 v1m.PolicyV1Interface
		})
	}
	fake.policyV1ReturnsOnCall[i] = struct {
		result1 v1m.PolicyV1Interface
	}{result1}
}

func (fake *FakeInterface) PolicyV1beta1() v1beta1m.PolicyV1beta1Interface {
	fake.policyV1beta1Mutex.Lock()
	ret, specificReturn := fake.policyV1beta1ReturnsOnCall[len(fake.policyV1beta1ArgsForCall)]
	fake.policyV1beta1ArgsForCall = append(fake.policyV1beta1ArgsForCall, struct {
	}{})
	stub := fake.PolicyV1beta1Stub
	fakeReturns := fake.policyV1beta1Returns
	fake.recordInvocation("PolicyV1beta1", []interface{}{})
	fake.policyV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) PolicyV1beta1CallCount() int {
	fake.policyV1beta1Mutex.RLock()
	defer fake.policyV1beta1Mutex.RUnlock()
	return len(fake.policyV1beta1ArgsForCall)
}

func (fake *FakeInterface) PolicyV1beta1Calls(stub func() v1beta1m.PolicyV1beta1Interface) {
	fake.policyV1beta1Mutex.Lock()
	defer fake.policyV1beta1Mutex.Unlock()
	fake.PolicyV1beta1Stub = stub
}

func (fake *FakeInterface) PolicyV1beta1Returns(result1 v1beta1m.PolicyV1beta1Interface) {
	fake.policyV1beta1Mutex.Lock()
	defer fake.policyV1beta1Mutex.Unlock()
	fake.PolicyV1beta1Stub = nil
	fake.policyV1beta1Returns = struct {
		result1 v1beta1m.PolicyV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) PolicyV1beta1ReturnsOnCall(i int, result1 v1beta1m.PolicyV1beta1Interface) {
	fake.policyV1beta1Mutex.Lock()
	defer fake.policyV1beta1Mutex.Unlock()
	fake.PolicyV1beta1Stub = nil
	if fake.policyV1beta1ReturnsOnCall == nil {
		fake.policyV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1m.PolicyV1beta1Interface
		})
	}
	fake.policyV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1m.PolicyV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1() v1n.RbacV1Interface {
	fake.rbacV1Mutex.Lock()
	ret, specificReturn := fake.rbacV1ReturnsOnCall[len(fake.rbacV1ArgsForCall)]
	fake.rbacV1ArgsForCall = append(fake.rbacV1ArgsForCall, struct {
	}{})
	stub := fake.RbacV1Stub
	fakeReturns := fake.rbacV1Returns
	fake.recordInvocation("RbacV1", []interface{}{})
	fake.rbacV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) RbacV1CallCount() int {
	fake.rbacV1Mutex.RLock()
	defer fake.rbacV1Mutex.RUnlock()
	return len(fake.rbacV1ArgsForCall)
}

func (fake *FakeInterface) RbacV1Calls(stub func() v1n.RbacV1Interface) {
	fake.rbacV1Mutex.Lock()
	defer fake.rbacV1Mutex.Unlock()
	fake.RbacV1Stub = stub
}

func (fake *FakeInterface) RbacV1Returns(result1 v1n.RbacV1Interface) {
	fake.rbacV1Mutex.Lock()
	defer fake.rbacV1Mutex.Unlock()
	fake.RbacV1Stub = nil
	fake.rbacV1Returns = struct {
		result1 v1n.RbacV1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1ReturnsOnCall(i int, result1 v1n.RbacV1Interface) {
	fake.rbacV1Mutex.Lock()
	defer fake.rbacV1Mutex.Unlock()
	fake.RbacV1Stub = nil
	if fake.rbacV1ReturnsOnCall == nil {
		fake.rbacV1ReturnsOnCall = make(map[int]struct {
			result1 v1n.RbacV1Interface
		})
	}
	fake.rbacV1ReturnsOnCall[i] = struct {
		result1 v1n.RbacV1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1alpha1() v1alpha1d.RbacV1alpha1Interface {
	fake.rbacV1alpha1Mutex.Lock()
	ret, specificReturn := fake.rbacV1alpha1ReturnsOnCall[len(fake.rbacV1alpha1ArgsForCall)]
	fake.rbacV1alpha1ArgsForCall = append(fake.rbacV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.RbacV1alpha1Stub
	fakeReturns := fake.rbacV1alpha1Returns
	fake.recordInvocation("RbacV1alpha1", []interface{}{})
	fake.rbacV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) RbacV1alpha1CallCount() int {
	fake.rbacV1alpha1Mutex.RLock()
	defer fake.rbacV1alpha1Mutex.RUnlock()
	return len(fake.rbacV1alpha1ArgsForCall)
}

func (fake *FakeInterface) RbacV1alpha1Calls(stub func() v1alpha1d.RbacV1alpha1Interface) {
	fake.rbacV1alpha1Mutex.Lock()
	defer fake.rbacV1alpha1Mutex.Unlock()
	fake.RbacV1alpha1Stub = stub
}

func (fake *FakeInterface) RbacV1alpha1Returns(result1 v1alpha1d.RbacV1alpha1Interface) {
	fake.rbacV1alpha1Mutex.Lock()
	defer fake.rbacV1alpha1Mutex.Unlock()
	fake.RbacV1alpha1Stub = nil
	fake.rbacV1alpha1Returns = struct {
		result1 v1alpha1d.RbacV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1alpha1ReturnsOnCall(i int, result1 v1alpha1d.RbacV1alpha1Interface) {
	fake.rbacV1alpha1Mutex.Lock()
	defer fake.rbacV1alpha1Mutex.Unlock()
	fake.RbacV1alpha1Stub = nil
	if fake.rbacV1alpha1ReturnsOnCall == nil {
		fake.rbacV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1d.RbacV1alpha1Interface
		})
	}
	fake.rbacV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1d.RbacV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1beta1() v1beta1n.RbacV1beta1Interface {
	fake.rbacV1beta1Mutex.Lock()
	ret, specificReturn := fake.rbacV1beta1ReturnsOnCall[len(fake.rbacV1beta1ArgsForCall)]
	fake.rbacV1beta1ArgsForCall = append(fake.rbacV1beta1ArgsForCall, struct {
	}{})
	stub := fake.RbacV1beta1Stub
	fakeReturns := fake.rbacV1beta1Returns
	fake.recordInvocation("RbacV1beta1", []interface{}{})
	fake.rbacV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) RbacV1beta1CallCount() int {
	fake.rbacV1beta1Mutex.RLock()
	defer fake.rbacV1beta1Mutex.RUnlock()
	return len(fake.rbacV1beta1ArgsForCall)
}

func (fake *FakeInterface) RbacV1beta1Calls(stub func() v1beta1n.RbacV1beta1Interface) {
	fake.rbacV1beta1Mutex.Lock()
	defer fake.rbacV1beta1Mutex.Unlock()
	fake.RbacV1beta1Stub = stub
}

func (fake *FakeInterface) RbacV1beta1Returns(result1 v1beta1n.RbacV1beta1Interface) {
	fake.rbacV1beta1Mutex.Lock()
	defer fake.rbacV1beta1Mutex.Unlock()
	fake.RbacV1beta1Stub = nil
	fake.rbacV1beta1Returns = struct {
		result1 v1beta1n.RbacV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) RbacV1beta1ReturnsOnCall(i int, result1 v1beta1n.RbacV1beta1Interface) {
	fake.rbacV1beta1Mutex.Lock()
	defer fake.rbacV1beta1Mutex.Unlock()
	fake.RbacV1beta1Stub = nil
	if fake.rbacV1beta1ReturnsOnCall == nil {
		fake.rbacV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1n.RbacV1beta1Interface
		})
	}
	fake.rbacV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1n.RbacV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1() v1o.SchedulingV1Interface {
	fake.schedulingV1Mutex.Lock()
	ret, specificReturn := fake.schedulingV1ReturnsOnCall[len(fake.schedulingV1ArgsForCall)]
	fake.schedulingV1ArgsForCall = append(fake.schedulingV1ArgsForCall, struct {
	}{})
	stub := fake.SchedulingV1Stub
	fakeReturns := fake.schedulingV1Returns
	fake.recordInvocation("SchedulingV1", []interface{}{})
	fake.schedulingV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) SchedulingV1CallCount() int {
	fake.schedulingV1Mutex.RLock()
	defer fake.schedulingV1Mutex.RUnlock()
	return len(fake.schedulingV1ArgsForCall)
}

func (fake *FakeInterface) SchedulingV1Calls(stub func() v1o.SchedulingV1Interface) {
	fake.schedulingV1Mutex.Lock()
	defer fake.schedulingV1Mutex.Unlock()
	fake.SchedulingV1Stub = stub
}

func (fake *FakeInterface) SchedulingV1Returns(result1 v1o.SchedulingV1Interface) {
	fake.schedulingV1Mutex.Lock()
	defer fake.schedulingV1Mutex.Unlock()
	fake.SchedulingV1Stub = nil
	fake.schedulingV1Returns = struct {
		result1 v1o.SchedulingV1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1ReturnsOnCall(i int, result1 v1o.SchedulingV1Interface) {
	fake.schedulingV1Mutex.Lock()
	defer fake.schedulingV1Mutex.Unlock()
	fake.SchedulingV1Stub = nil
	if fake.schedulingV1ReturnsOnCall == nil {
		fake.schedulingV1ReturnsOnCall = make(map[int]struct {
			result1 v1o.SchedulingV1Interface
		})
	}
	fake.schedulingV1ReturnsOnCall[i] = struct {
		result1 v1o.SchedulingV1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1alpha1() v1alpha1e.SchedulingV1alpha1Interface {
	fake.schedulingV1alpha1Mutex.Lock()
	ret, specificReturn := fake.schedulingV1alpha1ReturnsOnCall[len(fake.schedulingV1alpha1ArgsForCall)]
	fake.schedulingV1alpha1ArgsForCall = append(fake.schedulingV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.SchedulingV1alpha1Stub
	fakeReturns := fake.schedulingV1alpha1Returns
	fake.recordInvocation("SchedulingV1alpha1", []interface{}{})
	fake.schedulingV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) SchedulingV1alpha1CallCount() int {
	fake.schedulingV1alpha1Mutex.RLock()
	defer fake.schedulingV1alpha1Mutex.RUnlock()
	return len(fake.schedulingV1alpha1ArgsForCall)
}

func (fake *FakeInterface) SchedulingV1alpha1Calls(stub func() v1alpha1e.SchedulingV1alpha1Interface) {
	fake.schedulingV1alpha1Mutex.Lock()
	defer fake.schedulingV1alpha1Mutex.Unlock()
	fake.SchedulingV1alpha1Stub = stub
}

func (fake *FakeInterface) SchedulingV1alpha1Returns(result1 v1alpha1e.SchedulingV1alpha1Interface) {
	fake.schedulingV1alpha1Mutex.Lock()
	defer fake.schedulingV1alpha1Mutex.Unlock()
	fake.SchedulingV1alpha1Stub = nil
	fake.schedulingV1alpha1Returns = struct {
		result1 v1alpha1e.SchedulingV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1alpha1ReturnsOnCall(i int, result1 v1alpha1e.SchedulingV1alpha1Interface) {
	fake.schedulingV1alpha1Mutex.Lock()
	defer fake.schedulingV1alpha1Mutex.Unlock()
	fake.SchedulingV1alpha1Stub = nil
	if fake.schedulingV1alpha1ReturnsOnCall == nil {
		fake.schedulingV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1e.SchedulingV1alpha1Interface
		})
	}
	fake.schedulingV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1e.SchedulingV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1beta1() v1beta1o.SchedulingV1beta1Interface {
	fake.schedulingV1beta1Mutex.Lock()
	ret, specificReturn := fake.schedulingV1beta1ReturnsOnCall[len(fake.schedulingV1beta1ArgsForCall)]
	fake.schedulingV1beta1ArgsForCall = append(fake.schedulingV1beta1ArgsForCall, struct {
	}{})
	stub := fake.SchedulingV1beta1Stub
	fakeReturns := fake.schedulingV1beta1Returns
	fake.recordInvocation("SchedulingV1beta1", []interface{}{})
	fake.schedulingV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) SchedulingV1beta1CallCount() int {
	fake.schedulingV1beta1Mutex.RLock()
	defer fake.schedulingV1beta1Mutex.RUnlock()
	return len(fake.schedulingV1beta1ArgsForCall)
}

func (fake *FakeInterface) SchedulingV1beta1Calls(stub func() v1beta1o.SchedulingV1beta1Interface) {
	fake.schedulingV1beta1Mutex.Lock()
	defer fake.schedulingV1beta1Mutex.Unlock()
	fake.SchedulingV1beta1Stub = stub
}

func (fake *FakeInterface) SchedulingV1beta1Returns(result1 v1beta1o.SchedulingV1beta1Interface) {
	fake.schedulingV1beta1Mutex.Lock()
	defer fake.schedulingV1beta1Mutex.Unlock()
	fake.SchedulingV1beta1Stub = nil
	fake.schedulingV1beta1Returns = struct {
		result1 v1beta1o.SchedulingV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) SchedulingV1beta1ReturnsOnCall(i int, result1 v1beta1o.SchedulingV1beta1Interface) {
	fake.schedulingV1beta1Mutex.Lock()
	defer fake.schedulingV1beta1Mutex.Unlock()
	fake.SchedulingV1beta1Stub = nil
	if fake.schedulingV1beta1ReturnsOnCall == nil {
		fake.schedulingV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1o.SchedulingV1beta1Interface
		})
	}
	fake.schedulingV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1o.SchedulingV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1() v1p.StorageV1Interface {
	fake.storageV1Mutex.Lock()
	ret, specificReturn := fake.storageV1ReturnsOnCall[len(fake.storageV1ArgsForCall)]
	fake.storageV1ArgsForCall = append(fake.storageV1ArgsForCall, struct {
	}{})
	stub := fake.StorageV1Stub
	fakeReturns := fake.storageV1Returns
	fake.recordInvocation("StorageV1", []interface{}{})
	fake.storageV1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) StorageV1CallCount() int {
	fake.storageV1Mutex.RLock()
	defer fake.storageV1Mutex.RUnlock()
	return len(fake.storageV1ArgsForCall)
}

func (fake *FakeInterface) StorageV1Calls(stub func() v1p.StorageV1Interface) {
	fake.storageV1Mutex.Lock()
	defer fake.storageV1Mutex.Unlock()
	fake.StorageV1Stub = stub
}

func (fake *FakeInterface) StorageV1Returns(result1 v1p.StorageV1Interface) {
	fake.storageV1Mutex.Lock()
	defer fake.storageV1Mutex.Unlock()
	fake.StorageV1Stub = nil
	fake.storageV1Returns = struct {
		result1 v1p.StorageV1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1ReturnsOnCall(i int, result1 v1p.StorageV1Interface) {
	fake.storageV1Mutex.Lock()
	defer fake.storageV1Mutex.Unlock()
	fake.StorageV1Stub = nil
	if fake.storageV1ReturnsOnCall == nil {
		fake.storageV1ReturnsOnCall = make(map[int]struct {
			result1 v1p.StorageV1Interface
		})
	}
	fake.storageV1ReturnsOnCall[i] = struct {
		result1 v1p.StorageV1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1alpha1() v1alpha1f.StorageV1alpha1Interface {
	fake.storageV1alpha1Mutex.Lock()
	ret, specificReturn := fake.storageV1alpha1ReturnsOnCall[len(fake.storageV1alpha1ArgsForCall)]
	fake.storageV1alpha1ArgsForCall = append(fake.storageV1alpha1ArgsForCall, struct {
	}{})
	stub := fake.StorageV1alpha1Stub
	fakeReturns := fake.storageV1alpha1Returns
	fake.recordInvocation("StorageV1alpha1", []interface{}{})
	fake.storageV1alpha1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) StorageV1alpha1CallCount() int {
	fake.storageV1alpha1Mutex.RLock()
	defer fake.storageV1alpha1Mutex.RUnlock()
	return len(fake.storageV1alpha1ArgsForCall)
}

func (fake *FakeInterface) StorageV1alpha1Calls(stub func() v1alpha1f.StorageV1alpha1Interface) {
	fake.storageV1alpha1Mutex.Lock()
	defer fake.storageV1alpha1Mutex.Unlock()
	fake.StorageV1alpha1Stub = stub
}

func (fake *FakeInterface) StorageV1alpha1Returns(result1 v1alpha1f.StorageV1alpha1Interface) {
	fake.storageV1alpha1Mutex.Lock()
	defer fake.storageV1alpha1Mutex.Unlock()
	fake.StorageV1alpha1Stub = nil
	fake.storageV1alpha1Returns = struct {
		result1 v1alpha1f.StorageV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1alpha1ReturnsOnCall(i int, result1 v1alpha1f.StorageV1alpha1Interface) {
	fake.storageV1alpha1Mutex.Lock()
	defer fake.storageV1alpha1Mutex.Unlock()
	fake.StorageV1alpha1Stub = nil
	if fake.storageV1alpha1ReturnsOnCall == nil {
		fake.storageV1alpha1ReturnsOnCall = make(map[int]struct {
			result1 v1alpha1f.StorageV1alpha1Interface
		})
	}
	fake.storageV1alpha1ReturnsOnCall[i] = struct {
		result1 v1alpha1f.StorageV1alpha1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1beta1() v1beta1p.StorageV1beta1Interface {
	fake.storageV1beta1Mutex.Lock()
	ret, specificReturn := fake.storageV1beta1ReturnsOnCall[len(fake.storageV1beta1ArgsForCall)]
	fake.storageV1beta1ArgsForCall = append(fake.storageV1beta1ArgsForCall, struct {
	}{})
	stub := fake.StorageV1beta1Stub
	fakeReturns := fake.storageV1beta1Returns
	fake.recordInvocation("StorageV1beta1", []interface{}{})
	fake.storageV1beta1Mutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInterface) StorageV1beta1CallCount() int {
	fake.storageV1beta1Mutex.RLock()
	defer fake.storageV1beta1Mutex.RUnlock()
	return len(fake.storageV1beta1ArgsForCall)
}

func (fake *FakeInterface) StorageV1beta1Calls(stub func() v1beta1p.StorageV1beta1Interface) {
	fake.storageV1beta1Mutex.Lock()
	defer fake.storageV1beta1Mutex.Unlock()
	fake.StorageV1beta1Stub = stub
}

func (fake *FakeInterface) StorageV1beta1Returns(result1 v1beta1p.StorageV1beta1Interface) {
	fake.storageV1beta1Mutex.Lock()
	defer fake.storageV1beta1Mutex.Unlock()
	fake.StorageV1beta1Stub = nil
	fake.storageV1beta1Returns = struct {
		result1 v1beta1p.StorageV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) StorageV1beta1ReturnsOnCall(i int, result1 v1beta1p.StorageV1beta1Interface) {
	fake.storageV1beta1Mutex.Lock()
	defer fake.storageV1beta1Mutex.Unlock()
	fake.StorageV1beta1Stub = nil
	if fake.storageV1beta1ReturnsOnCall == nil {
		fake.storageV1beta1ReturnsOnCall = make(map[int]struct {
			result1 v1beta1p.StorageV1beta1Interface
		})
	}
	fake.storageV1beta1ReturnsOnCall[i] = struct {
		result1 v1beta1p.StorageV1beta1Interface
	}{result1}
}

func (fake *FakeInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.admissionregistrationV1Mutex.RLock()
	defer fake.admissionregistrationV1Mutex.RUnlock()
	fake.admissionregistrationV1beta1Mutex.RLock()
	defer fake.admissionregistrationV1beta1Mutex.RUnlock()
	fake.appsV1Mutex.RLock()
	defer fake.appsV1Mutex.RUnlock()
	fake.appsV1beta1Mutex.RLock()
	defer fake.appsV1beta1Mutex.RUnlock()
	fake.appsV1beta2Mutex.RLock()
	defer fake.appsV1beta2Mutex.RUnlock()
	fake.authenticationV1Mutex.RLock()
	defer fake.authenticationV1Mutex.RUnlock()
	fake.authenticationV1beta1Mutex.RLock()
	defer fake.authenticationV1beta1Mutex.RUnlock()
	fake.authorizationV1Mutex.RLock()
	defer fake.authorizationV1Mutex.RUnlock()
	fake.authorizationV1beta1Mutex.RLock()
	defer fake.authorizationV1beta1Mutex.RUnlock()
	fake.autoscalingV1Mutex.RLock()
	defer fake.autoscalingV1Mutex.RUnlock()
	fake.autoscalingV2Mutex.RLock()
	defer fake.autoscalingV2Mutex.RUnlock()
	fake.autoscalingV2beta1Mutex.RLock()
	defer fake.autoscalingV2beta1Mutex.RUnlock()
	fake.autoscalingV2beta2Mutex.RLock()
	defer fake.autoscalingV2beta2Mutex.RUnlock()
	fake.batchV1Mutex.RLock()
	defer fake.batchV1Mutex.RUnlock()
	fake.batchV1beta1Mutex.RLock()
	defer fake.batchV1beta1Mutex.RUnlock()
	fake.certificatesV1Mutex.RLock()
	defer fake.certificatesV1Mutex.RUnlock()
	fake.certificatesV1beta1Mutex.RLock()
	defer fake.certificatesV1beta1Mutex.RUnlock()
	fake.coordinationV1Mutex.RLock()
	defer fake.coordinationV1Mutex.RUnlock()
	fake.coordinationV1beta1Mutex.RLock()
	defer fake.coordinationV1beta1Mutex.RUnlock()
	fake.coreV1Mutex.RLock()
	defer fake.coreV1Mutex.RUnlock()
	fake.discoveryMutex.RLock()
	defer fake.discoveryMutex.RUnlock()
	fake.discoveryV1Mutex.RLock()
	defer fake.discoveryV1Mutex.RUnlock()
	fake.discoveryV1beta1Mutex.RLock()
	defer fake.discoveryV1beta1Mutex.RUnlock()
	fake.eventsV1Mutex.RLock()
	defer fake.eventsV1Mutex.RUnlock()
	fake.eventsV1beta1Mutex.RLock()
	defer fake.eventsV1beta1Mutex.RUnlock()
	fake.extensionsV1beta1Mutex.RLock()
	defer fake.extensionsV1beta1Mutex.RUnlock()
	fake.flowcontrolV1alpha1Mutex.RLock()
	defer fake.flowcontrolV1alpha1Mutex.RUnlock()
	fake.flowcontrolV1beta1Mutex.RLock()
	defer fake.flowcontrolV1beta1Mutex.RUnlock()
	fake.flowcontrolV1beta2Mutex.RLock()
	defer fake.flowcontrolV1beta2Mutex.RUnlock()
	fake.internalV1alpha1Mutex.RLock()
	defer fake.internalV1alpha1Mutex.RUnlock()
	fake.networkingV1Mutex.RLock()
	defer fake.networkingV1Mutex.RUnlock()
	fake.networkingV1alpha1Mutex.RLock()
	defer fake.networkingV1alpha1Mutex.RUnlock()
	fake.networkingV1beta1Mutex.RLock()
	defer fake.networkingV1beta1Mutex.RUnlock()
	fake.nodeV1Mutex.RLock()
	defer fake.nodeV1Mutex.RUnlock()
	fake.nodeV1alpha1Mutex.RLock()
	defer fake.nodeV1alpha1Mutex.RUnlock()
	fake.nodeV1beta1Mutex.RLock()
	defer fake.nodeV1beta1Mutex.RUnlock()
	fake.policyV1Mutex.RLock()
	defer fake.policyV1Mutex.RUnlock()
	fake.policyV1beta1Mutex.RLock()
	defer fake.policyV1beta1Mutex.RUnlock()
	fake.rbacV1Mutex.RLock()
	defer fake.rbacV1Mutex.RUnlock()
	fake.rbacV1alpha1Mutex.RLock()
	defer fake.rbacV1alpha1Mutex.RUnlock()
	fake.rbacV1beta1Mutex.RLock()
	defer fake.rbacV1beta1Mutex.RUnlock()
	fake.schedulingV1Mutex.RLock()
	defer fake.schedulingV1Mutex.RUnlock()
	fake.schedulingV1alpha1Mutex.RLock()
	defer fake.schedulingV1alpha1Mutex.RUnlock()
	fake.schedulingV1beta1Mutex.RLock()
	defer fake.schedulingV1beta1Mutex.RUnlock()
	fake.storageV1Mutex.RLock()
	defer fake.storageV1Mutex.RUnlock()
	fake.storageV1alpha1Mutex.RLock()
	defer fake.storageV1alpha1Mutex.RUnlock()
	fake.storageV1beta1Mutex.RLock()
	defer fake.storageV1beta1Mutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kubernetes.Interface = new(FakeInterface)

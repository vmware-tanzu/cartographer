//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by diegen. DO NOT EDIT.

package dies

import (
	"carto.run/blueprints/api/v1alpha1"
	v1 "dies.dev/apis/meta/v1"
	json "encoding/json"
	fmtx "fmt"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
)

var ClusterBlueprintTypeBlank = (&ClusterBlueprintTypeDie{}).DieFeed(v1alpha1.ClusterBlueprintType{})

type ClusterBlueprintTypeDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       v1alpha1.ClusterBlueprintType
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *ClusterBlueprintTypeDie) DieImmutable(immutable bool) *ClusterBlueprintTypeDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *ClusterBlueprintTypeDie) DieFeed(r v1alpha1.ClusterBlueprintType) *ClusterBlueprintTypeDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &ClusterBlueprintTypeDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *ClusterBlueprintTypeDie) DieFeedPtr(r *v1alpha1.ClusterBlueprintType) *ClusterBlueprintTypeDie {
	if r == nil {
		r = &v1alpha1.ClusterBlueprintType{}
	}
	return d.DieFeed(*r)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeDie) DieFeedRawExtension(raw runtime.RawExtension) *ClusterBlueprintTypeDie {
	b, _ := json.Marshal(raw)
	r := v1alpha1.ClusterBlueprintType{}
	_ = json.Unmarshal(b, &r)
	return d.DieFeed(r)
}

// DieRelease returns the resource managed by the die.
func (d *ClusterBlueprintTypeDie) DieRelease() v1alpha1.ClusterBlueprintType {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *ClusterBlueprintTypeDie) DieReleasePtr() *v1alpha1.ClusterBlueprintType {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *ClusterBlueprintTypeDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeDie) DieReleaseRawExtension() runtime.RawExtension {
	r := d.DieReleasePtr()
	b, _ := json.Marshal(r)
	raw := runtime.RawExtension{}
	_ = json.Unmarshal(b, &raw)
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *ClusterBlueprintTypeDie) DieStamp(fn func(r *v1alpha1.ClusterBlueprintType)) *ClusterBlueprintTypeDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *ClusterBlueprintTypeDie) DeepCopy() *ClusterBlueprintTypeDie {
	r := *d.r.DeepCopy()
	return &ClusterBlueprintTypeDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*ClusterBlueprintTypeDie)(nil)

func (d *ClusterBlueprintTypeDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *ClusterBlueprintTypeDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *ClusterBlueprintTypeDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *ClusterBlueprintTypeDie) UnmarshalJSON(b []byte) error {
	if d == ClusterBlueprintTypeBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &v1alpha1.ClusterBlueprintType{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *ClusterBlueprintTypeDie) APIVersion(v string) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *ClusterBlueprintTypeDie) Kind(v string) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *ClusterBlueprintTypeDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// SpecDie stamps the resource's spec field with a mutable die.
func (d *ClusterBlueprintTypeDie) SpecDie(fn func(d *ClusterBlueprintTypeSpecDie)) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		d := ClusterBlueprintTypeSpecBlank.DieImmutable(false).DieFeed(r.Spec)
		fn(d)
		r.Spec = d.DieRelease()
	})
}

// StatusDie stamps the resource's status field with a mutable die.
func (d *ClusterBlueprintTypeDie) StatusDie(fn func(d *ClusterBlueprintTypeStatusDie)) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		d := ClusterBlueprintTypeStatusBlank.DieImmutable(false).DieFeed(r.Status)
		fn(d)
		r.Status = d.DieRelease()
	})
}

func (d *ClusterBlueprintTypeDie) Spec(v v1alpha1.ClusterBlueprintTypeSpec) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		r.Spec = v
	})
}

func (d *ClusterBlueprintTypeDie) Status(v v1alpha1.ClusterBlueprintTypeStatus) *ClusterBlueprintTypeDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintType) {
		r.Status = v
	})
}

var ClusterBlueprintTypeSpecBlank = (&ClusterBlueprintTypeSpecDie{}).DieFeed(v1alpha1.ClusterBlueprintTypeSpec{})

type ClusterBlueprintTypeSpecDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       v1alpha1.ClusterBlueprintTypeSpec
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *ClusterBlueprintTypeSpecDie) DieImmutable(immutable bool) *ClusterBlueprintTypeSpecDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *ClusterBlueprintTypeSpecDie) DieFeed(r v1alpha1.ClusterBlueprintTypeSpec) *ClusterBlueprintTypeSpecDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &ClusterBlueprintTypeSpecDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *ClusterBlueprintTypeSpecDie) DieFeedPtr(r *v1alpha1.ClusterBlueprintTypeSpec) *ClusterBlueprintTypeSpecDie {
	if r == nil {
		r = &v1alpha1.ClusterBlueprintTypeSpec{}
	}
	return d.DieFeed(*r)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeSpecDie) DieFeedRawExtension(raw runtime.RawExtension) *ClusterBlueprintTypeSpecDie {
	b, _ := json.Marshal(raw)
	r := v1alpha1.ClusterBlueprintTypeSpec{}
	_ = json.Unmarshal(b, &r)
	return d.DieFeed(r)
}

// DieRelease returns the resource managed by the die.
func (d *ClusterBlueprintTypeSpecDie) DieRelease() v1alpha1.ClusterBlueprintTypeSpec {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *ClusterBlueprintTypeSpecDie) DieReleasePtr() *v1alpha1.ClusterBlueprintTypeSpec {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *ClusterBlueprintTypeSpecDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeSpecDie) DieReleaseRawExtension() runtime.RawExtension {
	r := d.DieReleasePtr()
	b, _ := json.Marshal(r)
	raw := runtime.RawExtension{}
	_ = json.Unmarshal(b, &raw)
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *ClusterBlueprintTypeSpecDie) DieStamp(fn func(r *v1alpha1.ClusterBlueprintTypeSpec)) *ClusterBlueprintTypeSpecDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *ClusterBlueprintTypeSpecDie) DeepCopy() *ClusterBlueprintTypeSpecDie {
	r := *d.r.DeepCopy()
	return &ClusterBlueprintTypeSpecDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*ClusterBlueprintTypeSpecDie)(nil)

func (d *ClusterBlueprintTypeSpecDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *ClusterBlueprintTypeSpecDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *ClusterBlueprintTypeSpecDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *ClusterBlueprintTypeSpecDie) UnmarshalJSON(b []byte) error {
	if d == ClusterBlueprintTypeSpecBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &v1alpha1.ClusterBlueprintTypeSpec{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *ClusterBlueprintTypeSpecDie) APIVersion(v string) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *ClusterBlueprintTypeSpecDie) Kind(v string) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *ClusterBlueprintTypeSpecDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// Qualifier is provided to avoid name collisions when blueprint authors start creating new types on a platform. There is a validation rule that metadata.name must be of the form: <qualifier>.<name> or <qualifier>-<name>. If the qualifier is omitted, then just <name> will suffice. Note: For TAP, this should be "tap" to avoid collisions with blueprint authors. We recommend other platforms follow this pattern also.
func (d *ClusterBlueprintTypeSpecDie) Qualifier(v string) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		r.Qualifier = v
	})
}

// Schema a JSON schema that is a valid representation of a type. Due to a limitation in k8s CRD definitions, this field accepts any valid JSON, however the validation will fail if it's not JSONSchema as per apiextensions.JSONSchemaProps (see: https://pkg.go.dev/k8s.io/apiextensions-apiserver/pkg/apis/apiextensions@v0.24.2#JSONSchemaProps) Todo: explain the problem with the absence of schema here, and semantic error checking
func (d *ClusterBlueprintTypeSpecDie) Schema(v *apiextensionsv1.JSON) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		r.Schema = v
	})
}

// Description describes this output to provide documentation to consumers.
func (d *ClusterBlueprintTypeSpecDie) Description(v string) *ClusterBlueprintTypeSpecDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeSpec) {
		r.Description = v
	})
}

var ClusterBlueprintTypeStatusBlank = (&ClusterBlueprintTypeStatusDie{}).DieFeed(v1alpha1.ClusterBlueprintTypeStatus{})

type ClusterBlueprintTypeStatusDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       v1alpha1.ClusterBlueprintTypeStatus
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *ClusterBlueprintTypeStatusDie) DieImmutable(immutable bool) *ClusterBlueprintTypeStatusDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *ClusterBlueprintTypeStatusDie) DieFeed(r v1alpha1.ClusterBlueprintTypeStatus) *ClusterBlueprintTypeStatusDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &ClusterBlueprintTypeStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *ClusterBlueprintTypeStatusDie) DieFeedPtr(r *v1alpha1.ClusterBlueprintTypeStatus) *ClusterBlueprintTypeStatusDie {
	if r == nil {
		r = &v1alpha1.ClusterBlueprintTypeStatus{}
	}
	return d.DieFeed(*r)
}

// DieFeedRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeStatusDie) DieFeedRawExtension(raw runtime.RawExtension) *ClusterBlueprintTypeStatusDie {
	b, _ := json.Marshal(raw)
	r := v1alpha1.ClusterBlueprintTypeStatus{}
	_ = json.Unmarshal(b, &r)
	return d.DieFeed(r)
}

// DieRelease returns the resource managed by the die.
func (d *ClusterBlueprintTypeStatusDie) DieRelease() v1alpha1.ClusterBlueprintTypeStatus {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *ClusterBlueprintTypeStatusDie) DieReleasePtr() *v1alpha1.ClusterBlueprintTypeStatus {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *ClusterBlueprintTypeStatusDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieReleaseRawExtension returns the resource managed by the die as an raw extension.
func (d *ClusterBlueprintTypeStatusDie) DieReleaseRawExtension() runtime.RawExtension {
	r := d.DieReleasePtr()
	b, _ := json.Marshal(r)
	raw := runtime.RawExtension{}
	_ = json.Unmarshal(b, &raw)
	return raw
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *ClusterBlueprintTypeStatusDie) DieStamp(fn func(r *v1alpha1.ClusterBlueprintTypeStatus)) *ClusterBlueprintTypeStatusDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *ClusterBlueprintTypeStatusDie) DeepCopy() *ClusterBlueprintTypeStatusDie {
	r := *d.r.DeepCopy()
	return &ClusterBlueprintTypeStatusDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*ClusterBlueprintTypeStatusDie)(nil)

func (d *ClusterBlueprintTypeStatusDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *ClusterBlueprintTypeStatusDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *ClusterBlueprintTypeStatusDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *ClusterBlueprintTypeStatusDie) UnmarshalJSON(b []byte) error {
	if d == ClusterBlueprintTypeStatusBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &v1alpha1.ClusterBlueprintTypeStatus{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (d *ClusterBlueprintTypeStatusDie) APIVersion(v string) *ClusterBlueprintTypeStatusDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeStatus) {
		r.APIVersion = v
	})
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (d *ClusterBlueprintTypeStatusDie) Kind(v string) *ClusterBlueprintTypeStatusDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeStatus) {
		r.Kind = v
	})
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *ClusterBlueprintTypeStatusDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *ClusterBlueprintTypeStatusDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeStatus) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

// Conditions follow k8s sig-arch guidelines: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
//
// # Possible Sub-Conditions are: ## SchemaValid Describes the validity of the spec.schema field. A reason "InvalidJSONAPISchema" means the Schema could not be parsed, and the Message will explain the error. You must provide valid [OpenAPI v3 Schema](https://swagger.io/specification/#schema-object)
func (d *ClusterBlueprintTypeStatusDie) Conditions(v ...metav1.Condition) *ClusterBlueprintTypeStatusDie {
	return d.DieStamp(func(r *v1alpha1.ClusterBlueprintTypeStatus) {
		r.Conditions = v
	})
}

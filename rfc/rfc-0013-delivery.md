# RFC 0013 Delivery

## Summary

This RFC proposes the introduction of four new resources to the carto.run/v1alpha1 API group to handle application delivery (i.e., CD, validation, and promotion).

## Motivation

Cartographer’s `SupplyChain` allows application operators to pave a path from app source code to GitOps-ready K8s configuration.
However, it does not handle deployment and promotion of that K8s configuration.

## Detailed Explanation

This RFC proposes the introduction of four new resources to the carto.run/v1alpha1 API group to handle this use case: `clusterdeliveries`, `deliverables`, `clusterdeploytemplates`, and `clusterdeliverytemplates`.

- **ClusterDeliveries** are cluster-scoped resources that enable application operators to define continuous delivery workflows.
  Delivery is analogous to SupplyChain, in that it specifies a list of resources that are created when requested by the developer.
  However, Deliveries are used to specify how K8s configuration is delivered to a series of environments (after it is generated by a SupplyChain).
  
- **Deliverables** are namespaced resources that enable application developers to specify K8s configuration.
  A Deliverable is analogous to a Workload, in that it instantiates the resources defined by the Delivery.

- **ClusterDeploymentTemplates** are cluster-scoped resources that enable application operators to specify resource templates that deploy environments.
  ClusterDeploymentTemplates take a deployment artifact and any number of additional source artifacts. They return a single deployment artifact.

  deployment, source[] -> deployment

- **ClusterDeploymentValidationTemplates** are cluster-scoped resources that enable application operators to specify resource templates that perform validations on a particular deployed environment.
  ClusterDeploymentValidationTemplates take a deployment artifact and any number of additional source artifacts. They return a single deployment artifact.

  deployment, source[] -> deployment

In addition to these resources, the following existing resources are valid in a ClusterDelivery:

- **ClusterSourceTemplates** are cluster-scoped resources that enable application operators to specify resource templates that process k8s configuration and output a revision of k8s configuration.
  In the context of ClusterDelivery, ClusterSourceTemplates take any number of source and config artifacts and return a single source artifact. 
  
  config[], source[] -> source

- **ClusterTemplates** are cluster-scoped resources that enable application operators to specify resource templates that process k8s configuration and have no output.
  In the context of ClusterDelivery, ClusterTemplates take any number of source and config artifacts and return nothing. 
  
  config[], source[] -> X
  
ClusterDeploymentTemplate resource specs are only modified when their returned deployment revision is no longer being processed by any ClusterDeploymentValidationTemplate resources.
This prevents an environment from changing while it is being validated by a ClusterDeploymentValidationTemplate resource.

Deployment artifacts represent a revision of K8s configuration source and therefore use the same structure as source artifacts.
When needed, deployment artifacts may be “cast” into source artifacts, because a deployment revision is a type of source revision.
For example, a ClusterTemplate that promotes a commit containing K8s configuration to a production branch might consume that commit as a deployment artifact from a ClusterDeploymentValidationTemplate that validated the deployment.
See the Staging Cluster example below.


## Rationale and Alternatives

Rationale:
- We should de-couple build (CI) and deployment (CD)
- SupplyChain takes application source code as input (via Workload), not K8s config

Alternatives:
- Deployment validations could be integrated into the ClusterDeploymentTemplate to avoid synchronization complexities
- Do nothing, keep using SupplyChain for deployment
- Do nothing, don't address CD

## Implementation

### API

Deliverable
```yaml
apiVersion: carto.run/v1alpha1
kind: Deliverable
metadata:
  name: <name>
  labels:
    app.tanzu.vmware.com/deliverable-type: <type>
spec:
  source:
    git:
      url: <url>
      subPath: <path>
      ref:
        branch: <branch>
```

ClusterDelivery
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDelivery
metadata:
  name: <name>
spec:
  selector:
    app.tanzu.vmware.com/deliverable-type: <type>
  resources:
    - name: config-provider
      templateRef:
        kind: <template-kind>
        name: <template-name>
      deployment: # kind=ClusterDeliveryTemplate 
        resource: <resource-name>
      sources: # kind=*
      - resource: <resource-name>
      configs: # kind=ClusterSourceTemplate
      - resource: <resource-name>

```

ClusterSourceTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterSourceTemplate
metadata:
  name: <name>
spec:
  urlPath: <jsonpath-in-status>
  revisionPath: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

ClusterDeploymentTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentTemplate
metadata:
  name: <name>
spec:
  observedCompletion: # uses observedGeneration
    succeeded:
      key: <jsonpath-in-status>
      value: <expected-value>
    failed:
      key: <jsonpath-in-status>
      value: <expected-value>
  observedMatches: # alternative to observedCompletion
  - input: <jsonpath-in-spec>
    output: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

ClusterDeploymentValidationTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentValidationTemplate
metadata:
  name: <name>
spec:
  observedCompletion: # uses observedGeneration
    succeeded:
      key: <jsonpath-in-status>
      value: <expected-value>
    failed:
      key: <jsonpath-in-status>
      value: <expected-value>
  observedMatches: # alternative to observedCompletion
  - input: <jsonpath-in-spec>
    output: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

## Examples

### Deploy-only

In the following simple example, the Delivery:

1. Fetches Kubernetes configuration from a git repository
2. Deploys to the cluster using kapp controller

Deliverable
```yaml
apiVersion: carto.run/v1alpha1
kind: Deliverable
metadata:
  name: my-app
  labels:
    app.tanzu.vmware.com/deliverable-type: web
spec:
  source:
    git:
      url: https://github.com/example/hello-world-ops
      ref:
        branch: prod
```

ClusterDelivery
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDelivery
metadata:
  name: delivery
spec:
  selector:
    app.tanzu.vmware.com/deliverable-type: web
  resources:
    - name: config-provider
      templateRef:
        kind: ClusterSourceTemplate
        name: git-repository
    - name: deployer
      templateRef:
        kind: ClusterDeploymentTemplate
        name: app-deploy
      source:
        resource: config-provider
```

ClusterSourceTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterSourceTemplate
metadata:
  name: source
spec:
  urlPath: .status.artifact.url
  revisionPath: .status.artifact.revision

  template:
    apiVersion: source.toolkit.fluxcd.io/v1beta1
    kind: GitRepository
    metadata:
      name: $(deliverable.metadata.name)$
    spec:
      interval: 1m
      url: $(deliverable.spec.source.git.url)$
      ref: $(deliverable.spec.source.git.ref)$
      gitImplementation: libgit2
      ignore: ""
```

ClusterDeploymentTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentTemplate
metadata:
  name: app-deploy
spec:
  observedCompletion: # uses observedGeneration
    succeeded: {key: 'status.conditions.#(type=="ReconcileSucceeded").status', value: "True"}
    failed:    {key: 'status.conditions.#(type=="ReconcileFailed").status', value: "False"}

  template:
    apiVersion: kappctrl.k14s.io/v1alpha1
    kind: App
    metadata:
      name: $(deliverable.metadata.name)$
    spec:
      serviceAccountName: default
      fetch:
       - http:
          url: $(source.url)$
          # grab only portion of download (optional)
          subPath: $(source.subPath)$
      template:
        - ytt: {}
      deploy:
        - kapp: {}
```

### Staging Cluster

In the following more complex example, the Delivery:

1. Fetches Kubernetes configuration from a git repository
2. Fetches Integration tests from the same git repository
3. Deploys to a staging cluster using kapp controller
4. Runs Integration and performance tests against deployed app
5. Promotes to production via pull request if integration tests pass

Deliverable
```yaml
apiVersion: carto.run/v1alpha1
kind: Deliverable
metadata:
  name: my-app
  labels:
    app.tanzu.vmware.com/deliverable-type: web
spec:
  config:
    git:
      url: https://github.com/ekcasey/hello-world-ops
      ref:
        branch: staging
```

ClusterDelivery
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDelivery
metadata:
  name: delivery
spec:
  selector:
    app.tanzu.vmware.com/deliverable-type: web
  resources:
    - name: config-provider
      templateRef:
        kind: ClusterSourceTemplate
        name: git-repository
    - name: deployer
      templateRef:
        kind: ClusterDeploymentTemplate
        name: app-deploy
      source:
        resource: config-provider
    - name: integration-tester
      templateRef:
        kind: ClusterDeliveryTemplate
        name: tekton-integration-tests
      deployment:
        resource: deployer
    - name: performance-tester
      templateRef:
        kind: ClusterDeliveryTemplate
        name: tekton-performance-pipeline
      deployment:
        resource: integration-tester
    - name: promoter
      templateRef:
        kind: ClusterTemplate
        name: git-merge
      sources:
      - resource: performance-tester # need way to merge parallel tests eventually
```

ClusterSourceTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterSourceTemplate
metadata:
  name: source
spec:
  urlPath: .status.artifact.url
  revisionPath: .status.artifact.revision

  template:
    apiVersion: source.toolkit.fluxcd.io/v1beta1
    kind: GitRepository
    metadata:
      name: $(deliverable.metadata.name)$
    spec:
      interval: 1m
      url: $(deliverable.spec.source.git.url)$
      ref: $(deliverable.spec.source.git.ref)$
      gitImplementation: libgit2
      ignore: ""
```

ClusterDeploymentTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentTemplate
metadata:
  name: app-deploy
spec:
  observedCompletion: # uses observedGeneration
    succeeded: {key: 'status.conditions.#(type=="ReconcileSucceeded").status', value: "True"}
    failed:    {key: 'status.conditions.#(type=="ReconcileFailed").status', value: "False"}

  template:
    apiVersion: kappctrl.k14s.io/v1alpha1
    kind: App
    metadata:
      name: $(deliverable.metadata.name)$
    spec:
      serviceAccountName: default
      fetch:
       - http:
          url: $(source.url)$
          # grab only portion of download (optional)
          subPath: $(source.subPath)$
      template:
        - ytt: {}
      deploy:
        - kapp: {}
```

ClusterDeploymentValidationTemplate - Integration Test
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentValidationTemplate
metadata:
  name: tekton-integration-tests
spec:


  # could also use observedCompletion
  observedMatches:
  - input: $(spec.inputs.revision)$
    output: $(status.latestInputs.revision)$

  template:
    apiVersion: carto.run/v1alpha1
    kind: Pipeline
    metadata:
      generateName: $(workload.name)$-integration-
    spec:
      inputs:
        url: $(deployment.url)$
        revision: $(deployment.revision)$
        pipelineName: test

      runTemplateRef:
        name: default-tekton-source-provider

```

ClusterDeploymentValidationTemplate - Performance Test
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeploymentValidationTemplate
metadata:
  name: tekton-performance-tests
spec:
  # could also use observedCompletion
  observedMatches:
  - input: $(spec.inputs.revision)$
    output: $(status.outputs.revision)$

  template:
    apiVersion: carto.run/v1alpha1
    kind: Pipeline
    metadata:
      generateName: $(workload.name)$-performance-
    spec:
      inputs:
        url: $(deployment.url)$
        revision: $(deployment.revision)$
        pipelineName: test

      runTemplateRef:
        name: default-tekton-source-provider

```

ClusterTemplate - Git Merge
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterTemplate
metadata:
  name: git-merge
spec:
  template:
    apiVersion: carto.run/v1alpha1
    kind: Pipeline
    metadata:
      generateName: $(workload.name)$-promotion-
    spec:
      inputs:
        url: $(source.url)$
        revision: $(source.revision)$
        pipeline: test

      runTemplateRef:
        name: default-tekton-template
```

PipelineRun - Tests
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterRunTemplate
metadata:
  name: default-tekton-source-provider
spec:
  completion:
    succeeded: {key: 'status.conditions.#(type=="Succeeded").status', value: "True"}
    failed:    {key: 'status.conditions.#(type=="Succeeded").status', value: "False"}

  template:
    apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: $(pipeline.metadata.name)$-
    spec:
      pipelineRef: 
        name: $(pipeline.spec.inputs.pipelineName)$

      workspaces:
        - name: source
          volumeClaimTemplate:
            spec:
              accessModes: [ ReadWriteOnce ]


      params:
        - name: source-url
          value: $(pipeline.spec.inputs.source-url)$
        - name: source-revision
          value: $(pipeline.spec.inputs.source-revision)$

```

## Unresolved Questions

1. What is going on with resource limits? It seems like they make sense to include in Deliverable but they currently live in Workload.

2. What is going on with the runtime environment? We could bake this into the config during the integration phase (SupplyChain) but users may want to set different values in different environments (e.g., staging vs. prod) and should therefore probably move to Deliverable?



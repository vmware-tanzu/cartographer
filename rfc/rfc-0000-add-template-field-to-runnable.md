# Meta

[meta]: #meta

- Name: Add template field to runnable
- Start Date: 2022-04-04
- Author(s): WaciumaWanjohi
- Status: Draft
- RFC Pull Request: (leave blank)
- Supersedes:

# Summary

[summary]: #summary

Runnable currently requires a reference to a ClusterRunTemplate in a field labeled `runTemplateRef`. This RFC adds
a `template` field to Runnable itself. The RFC proposes removing ClusterRunTemplate, but the alternative approach
discusses keeping it and having the `template` field live alongside `runTemplateRef`.

# Motivation

[motivation]: #motivation

There is currently an RFC in review proposing that Carto users should be able to notate supply chain templates
(ClusterSourceTemplate, ClusterImageTemplate, etc) with a `lifecyle:immutable` field and have a Runnable and
ClusterRunTemplate generated by the controller. There have been concerns raised that a workload submission leading to
the creation of a cluster scoped Carto resource (ClusterRunTemplate) is a poor pattern. Adding the `template` field to
Runnable would address this concern.

# What it is

[what-it-is]: #what-it-is

The `templateRef` field would be removed from the Runnable and a `template` field added. The inputs field from Runnable
would similarly be removed. An `outputs` field would be added to the Runnable.

As an example, consider a Runnable/ClusterRunTemplate defined in the current manner:

```yaml
---
apiVersion: carto.run/v1alpha1
kind: ClusterRunTemplate
metadata:
  name: md-linting-pipelinerun
spec:
  template:
    apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: $(runnable.metadata.name)$-pipeline-run-
    spec:
      pipelineRef:
        name: linter-pipeline
      params:
        - name: repository
          value: $(runnable.spec.inputs.repository)$
        - name: revision
          value: $(runnable.spec.inputs.revision)$
      workspaces:
        - name: shared-workspace
          volumeClaimTemplate:
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 256Mi
  outputs:
    url: spec.params[?(@.name=="repository")].value
    revision: spec.params[?(@.name=="revision")].value

---
apiVersion: carto.run/v1alpha1
kind: Runnable
metadata:
  name: linter
spec:
  runTemplateRef:
    name: md-linting-pipelinerun
  inputs:
    repository: some-repo
    revision: some-sha
  serviceAccountName: pipeline-run-management-sa
```

This would become the single Runnable here:

```yaml
apiVersion: carto.run/v1alpha1
kind: Runnable
metadata:
  name: linter
spec:
  serviceAccountName: pipeline-run-management-sa
  template:
    apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
      generateName: some-name-pipeline-run-
    spec:
      pipelineRef:
        name: linter-pipeline
      params:
        - name: repository
          value: some-repo
        - name: revision
          value: some-sha
      workspaces:
        - name: shared-workspace
          volumeClaimTemplate:
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 256Mi
  outputs:
    url: spec.params[?(@.name=="repository")].value
    revision: spec.params[?(@.name=="revision")].value
```

The target persona is Cartographer maintainers; the main driver of this is to enable app operators to create templates
that leverage Runnable without needing to submit/manage ClusterRunTemplates.
See [this RFC](https://github.com/vmware-tanzu/cartographer/pull/705) for discussion of that use case.

# How it Works

[how-it-works]: #how-it-works

The object defined in the Runnable is submitted to the cluster. The runnable exposes the output fields defined in
the runnable's own status. Care should be taken to garbage collect objects submitted by a runnable if the GVK or
name of the object is changed.

# Migration

[migration]: #migration

See [spec-changes].

This RFC would require a version bump for Runnable. There is no technical reason that Runnables with valid
references to ClusterRunTemplate could not be translated into Runnables with template fields embedded.

The [alternatives] section describes keeping `runTemplateRef` alongside `template`. This option presents a purely
additive change.

# Drawbacks

[drawbacks]: #drawbacks

This runs a bit counter to the design of Cartographer, which has template objects that pair with an owner that
provides values to the template. These template objects are meant to be reuseable. In this case they are not.

This could be seen as the tail wagging the dog. Rather than simplifying the direct use case of Runnable, this makes
the direct use case worse, in pursuit of slightly smoothing out the automation of another feature (supply chain
templates automatically creating Runnables).

# Alternatives

[alternatives]: #alternatives

Rather than removing ClusterRunTemplates altogether, the `template` field option could exist alongside the the
`runTemplateRef` field. This has the advantage of preserving the owner-template relationship described in the
[drawbacks] section above. This does lead to its own complications:

- Runnable user tutorials becomes more complicated. We have to explain the choice before users. Either 1) use
  ClusterRunTemplate and Runnable with templateRef and inputs; or 2) use Runnable with template and outputs. Failing
  that we'd at least have to tell them to ignore the template and output fields they see in the Runnable CRD.
- The logic of the Carto's Runnable controller becomes more complicated. The controller has to handle these two
  different ways of specifying a Runnable.

# Prior Art

[prior-art]: #prior-art

# Unresolved Questions

[unresolved-questions]: #unresolved-questions

Is the field name `template` even appropriate? Nothing is being templated, an object is completely defined in the
Runnable. Perhaps the name `object` or `objectDef` is more appropriate?

# Spec. Changes (OPTIONAL)

[spec-changes]: #spec-changes

This RFC entails at least:

- addition of `template` field to the Runnable CRD
- addition of `outputs` field to the Runnable CRD

It also entails the following (although the [alternatives] discuss the pro/con of not doing this):

- removal of the ClusterRunTemplate CRD
- removal of the `runTemplateRef` field from Runnable CRD
- removal of the `inputs` field from Runnable CRD
